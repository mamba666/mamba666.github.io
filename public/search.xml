<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vue2.6开发web应用的准备</title>
    <url>/2020/03/23/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91vue2.6%20web%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><blockquote>
<p>第一步工作当然是搭建一个vue的项目，这里使用 <strong>@vue/cli</strong>。即最新版的脚手架工具。这次就不在使用github上传代码了。直接在本地写。</p>
</blockquote>
<p>先安装脚手架，然后使用vue的ui工具可视化的创建一个项目</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cnpm install -g @vue/cli</span><br><span class="line">vue cli</span><br></pre></td></tr></table></figure>

<p>稍等片刻，创建完成之后就是这样的一个目录结构。</p>
<p>先讲讲每一个文件夹的作用吧</p>
<ul>
<li>assets：用来存放如css，js，iconfont等静态的资源</li>
<li>components：用来存放router文件夹的页面的组件</li>
<li>router：应用有几个页面router就有几个文件</li>
<li>store：vuex在这里</li>
<li>views：至于它，我都习惯删掉。</li>
<li>main.js：是一个主的文件</li>
</ul>
<p><img src="/images/20.png" alt=""></p>
<p>修改完成之后是这样</p>
<p><img src="/images/21.png" alt=""></p>
<h2 id="必要的前期准备工作（随着事件的推移，可能某些就不必要了）"><a href="#必要的前期准备工作（随着事件的推移，可能某些就不必要了）" class="headerlink" title="必要的前期准备工作（随着事件的推移，可能某些就不必要了）"></a>必要的前期准备工作（随着事件的推移，可能某些就不必要了）</h2><h3 id="修改-public-中的index-html"><a href="#修改-public-中的index-html" class="headerlink" title="修改 public 中的index.html"></a>修改 public 中的index.html</h3><p>将meta标签修改为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="引入border-css-reset-css到assets中的styles中"><a href="#引入border-css-reset-css到assets中的styles中" class="headerlink" title="引入border.css  reset.css到assets中的styles中"></a>引入border.css  reset.css到assets中的styles中</h3><ul>
<li>border.css：用来解决移动端一像素边框问题。因为分辨率的问题</li>
<li>reset.css：用来重置默认样式</li>
</ul>
<p>因为需要全局使用，所以需要在main.js中引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @代表src目录。后续会在vue.config.js中增加快捷目录。因为styles使用的太多了</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"@/assets/styles/border.css"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"@/assets/styles/reset.css"</span></span><br></pre></td></tr></table></figure>

<h3 id="解决移动端300ms点击延迟事件"><a href="#解决移动端300ms点击延迟事件" class="headerlink" title="解决移动端300ms点击延迟事件"></a>解决移动端300ms点击延迟事件</h3><blockquote>
<p>但是我觉得如今没有必要在使用这个插件了，因为已经2020年了。浏览器等已经非常成熟，而这个插件发布于2015，年代久远。所以这里只是提一嘴，并没有真的去安装它</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install fastclick -S</span><br></pre></td></tr></table></figure>

<h3 id="配置webpack（别名alias）"><a href="#配置webpack（别名alias）" class="headerlink" title="配置webpack（别名alias）"></a>配置webpack（别名alias）</h3><blockquote>
<p>在根目录创建一个vue.config.js，用来自定义webpack    </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">"path"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。</span></span><br><span class="line">  <span class="comment">// 允许对内部的 webpack 配置进行更细粒度的修改。</span></span><br><span class="line">  chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(<span class="string">'styles'</span>, resolve(<span class="string">'src/assets/styles'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用stylus"><a href="#使用stylus" class="headerlink" title="使用stylus"></a>使用stylus</h3><p>首先需要安装必备的插件，因为使用 vue ui 创建项目时已经设置了stylus，所以不必在安装</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install stylus stylus-loader -S</span><br></pre></td></tr></table></figure>

<p>有两点需要注意</p>
<ul>
<li>scoped：代表这个css只对当前组件有用，不会影响到其他组件</li>
<li>如过要在stylus中引用其他文件，则需要使用  <strong>~@import “path”  要格外注意，不要忘记前面的波浪线</strong></li>
</ul>
<h3 id="使用iconfont"><a href="#使用iconfont" class="headerlink" title="使用iconfont"></a>使用iconfont</h3><p>这个就不赘述了。下载完成后按照说明来即可。<strong>因为iconfont可能每个页面都会使用，所以要在main.js中引入</strong></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs操作mysql</title>
    <url>/2020/03/20/nodejs%E6%93%8D%E4%BD%9Cmysql/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>这里不用多赘述，网上一大堆。但是要注意，最好选用官网的安装包而不是压缩包。傻瓜式安装即可。<strong>还有一点，在选择密码验证时，要选择兼容的5.0版本</strong></p>
</blockquote>
<h1 id="nodejs连接mysql"><a href="#nodejs连接mysql" class="headerlink" title="nodejs连接mysql"></a>nodejs连接mysql</h1><ol>
<li>先安装mysql插件</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install mysql -S</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>按照官网的模板写出下面的代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用mysql插件</span></span><br><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">"mysql"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置mysql</span></span><br><span class="line"><span class="keyword">const</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  <span class="comment">// 默认host为localhost</span></span><br><span class="line">  <span class="comment">// host:"localhost"</span></span><br><span class="line">  user: <span class="string">"root"</span>,</span><br><span class="line">  password: <span class="string">"lwjkkkbbb1997"</span>,</span><br><span class="line">  <span class="comment">// port默认为3306</span></span><br><span class="line">  <span class="comment">// port:3306</span></span><br><span class="line">  database: <span class="string">"demo"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接mysql</span></span><br><span class="line">connection.connect()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行sql语句的操作</span></span><br><span class="line">connection.query(<span class="string">"select * from users"</span>, (err, result) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">connection.end()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>初识nuxt.js</title>
    <url>/2020/03/19/%E5%88%9D%E8%AF%86nuxt.js/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="什么是nuxt-js"><a href="#什么是nuxt-js" class="headerlink" title="什么是nuxt.js"></a>什么是nuxt.js</h1><blockquote>
<p>nuxt.js是一个基于vue的ssr框架。简单说nuxtjs项目，它其实就是一个vue的项目融合一个node.js server项目，这里node服务有两个作用，第一点是代替浏览器的工作,笼统理解就是在created时的请求数据和页面渲染，第二点是当作静态文件服务器，把渲染好的页面返回给用户。</p>
</blockquote>
<h1 id="nuxt-js的路由"><a href="#nuxt-js的路由" class="headerlink" title="nuxt.js的路由"></a>nuxt.js的路由</h1><blockquote>
<p>这一点很方便，在以往，我们创建一个页面需要跳转，就需要使用到vue-router，并且还要配置。但是使用nuxt.js直接写页面就可以实现路由功能</p>
</blockquote>
<p>这里使用的是nuxt-link，而不是router-link。自己试了一下router-link一样可以生效。就是这么简单，就实现了路由。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;nuxt-link class&#x3D;&quot;button&quot; to&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">        hello nuxt.js</span><br><span class="line">    &lt;&#x2F;nuxt-link&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<h1 id="layouts"><a href="#layouts" class="headerlink" title="layouts"></a>layouts</h1><p>layouts里有一个 default.vue。很诡异的是这个 <strong><nuxt /></strong>。当我把这个注释掉后不管是首页还是自己创建的页面内容全没了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;nuxt /&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>官方文档有一句话引起了我的注意：<strong>提示: 别忘了在布局文件中添加 <nuxt/> 组件用于显示页面的主体内容。</strong>显而易见， <nuxt/> 是用来显示页面主体的，这也解释了为什么没有它页面上什么都不见了。这里只做一个了解，后续在深入。</p>
<p>还有一点。default是默认的意思。即只要页面没有配置layouts，那么默认的模板就是default。</p>
<p>补充一下， <nuxt/>可以按照 <router-view/>去理解。这样就解释的通了</p>
<h2 id="使用layouts"><a href="#使用layouts" class="headerlink" title="使用layouts"></a>使用layouts</h2><p>先创建一个layouts/about.vue的模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"about"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>about layouts<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nuxt</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在pages/about.bue中使用这个模板。使用layout声明此页面使用about模板</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  layout: <span class="string">'about'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="在nuxt-js中使用koa2"><a href="#在nuxt-js中使用koa2" class="headerlink" title="在nuxt.js中使用koa2"></a>在nuxt.js中使用koa2</h1><ol>
<li>首先写一个接口测试一下</li>
</ol>
<p>在server/interface下新建city.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router=<span class="built_in">require</span>(<span class="string">"koa-router"</span>)()</span><br><span class="line">router.prefix(<span class="string">"/city"</span>)</span><br><span class="line">router.get(<span class="string">"/list"</span>,<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    ctx.body=&#123;</span><br><span class="line">        list:[<span class="string">"北京"</span>,<span class="string">"石首"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在server下的index.js中引用注册这个路由</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> interCity <span class="keyword">from</span> <span class="string">'./interface/city'</span></span><br><span class="line">app.use(interCity.routes(), interCity.allowedMethods())</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试接口是否能跑通,直接在浏览器输入<a href="http://localhost:3000/city/list" target="_blank" rel="noopener">http://localhost:3000/city/list</a> 即可</li>
</ol>
<h1 id="在nuxt-js中使用后端数据"><a href="#在nuxt-js中使用后端数据" class="headerlink" title="在nuxt.js中使用后端数据"></a>在nuxt.js中使用后端数据</h1><ol>
<li>首先得把上面的三个步骤搞通，即能在页面中访问到后端数据。接下来就是如何使用了。以循环一个列表为例子</li>
<li>使用axios请求接口。要注意，这里的server不是分离的。所以暂时没有涉及到跨域问题（前后端都是通过一个端口启动）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  <span class="keyword">this</span>.getCityInfo()</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  getCityInfo () &#123;</span><br><span class="line">    axios.get(<span class="string">'/city/list'</span>).then(<span class="keyword">this</span>.succ)</span><br><span class="line">  &#125;,</span><br><span class="line">  succ (res) &#123;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-unused-vars</span></span><br><span class="line">    <span class="keyword">const</span> &#123; status, statusText, <span class="attr">data</span>: &#123; list &#125; &#125; = res</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-console</span></span><br><span class="line">    <span class="built_in">console</span>.log(list)</span><br><span class="line">    <span class="comment">// 这里的意思是将取到的list赋值给组件的list</span></span><br><span class="line">    <span class="keyword">this</span>.list = list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在list拿到值后就可以开始渲染了。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item,index) of list"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">	&#123;&#123; list[index] &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>nuxt.js</category>
      </categories>
  </entry>
  <entry>
    <title>Koa2与Vue前后端分离实践</title>
    <url>/2020/03/18/koa2%E4%B8%8Evue%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>折煞我也！！！！   简直颠覆认知</p>
</blockquote>
<p>不多讲了，直接看vue.config.js代码。可以发现很多注释掉的代码，并且是曾经让我琢磨了很久的代码，因为解决了我的mook数据的显示问题。但时至今日，才自己真正摸索出来前后端分离应该如何做。并且曾经听说过，其实没有必要写mooc数据，这个是后话了。接下来讲讲在组件中如何跨域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">//const mockdataindex=require("./mock/index.json")</span></span><br><span class="line"><span class="comment">//const mockdatacity=require("./mock/city.json")</span></span><br><span class="line"><span class="comment">//const mockdatadetail=require("./mock/detail.json")</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    lintOnSave: <span class="literal">true</span>,</span><br><span class="line">    chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">        .set(<span class="string">'styles'</span>,resolve(<span class="string">'src/assets/styles'</span>))</span><br><span class="line">        <span class="comment">// 这里只写了两个个，你可以自己再加，按这种格式.set('', resolve(''))</span></span><br><span class="line">        .set(<span class="string">'common'</span>,resolve(<span class="string">'src/common'</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        <span class="comment">//当Home.vue中的路径过来时，/api/index.json   因为是api开头，</span></span><br><span class="line">        <span class="comment">//所以这个路径被跨域到 http://localhost:8080/mock/index.json </span></span><br><span class="line">        <span class="comment">//即实际上访问8080时，访问的是http://localhost:8080/mock/index.json</span></span><br><span class="line">        <span class="comment">//这样就拿到了mooc的数据。</span></span><br><span class="line">        <span class="comment">//拿到之后，就回到vue开始执行then。   </span></span><br><span class="line">        <span class="comment">//到此结束！！！！</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">                pathRewrite:&#123;</span><br><span class="line">                    <span class="string">'^/api'</span>:<span class="string">'/api'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//用来显示假数据，即如果直接访问 http://localhost:8080/api/index.json</span></span><br><span class="line">        <span class="comment">//就会在页面打印mock数据</span></span><br><span class="line">        <span class="comment">// port:8080,</span></span><br><span class="line">        <span class="comment">// before(app)&#123;</span></span><br><span class="line">        <span class="comment">//     app.get('/api/index.json',(req,res,next)=&gt;&#123;</span></span><br><span class="line">        <span class="comment">//         res.json(mockdataindex)</span></span><br><span class="line">        <span class="comment">//     &#125;)</span></span><br><span class="line">        <span class="comment">//     app.get('/api/city.json',(req,res,next)=&gt;&#123;</span></span><br><span class="line">        <span class="comment">//         res.json(mockdatacity)</span></span><br><span class="line">        <span class="comment">//     &#125;)</span></span><br><span class="line">        <span class="comment">//     app.get('/api/detail.json',(req,res,next)=&gt;&#123;</span></span><br><span class="line">        <span class="comment">//         res.json(mockdatadetail)</span></span><br><span class="line">        <span class="comment">//     &#125;)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>组件中如何写？这里的getCity实际上就是koa2提供的一个接口。只有在 vue.config.js中设置了跨域才会生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">"/api/user/getCity"</span>)</span><br></pre></td></tr></table></figure>

<p>看看koa2中getCity到底做了什么。如果输入<a href="http://localhost:3000/api/user/getCity" target="_blank" rel="noopener">http://localhost:3000/api/user/getCity</a> 就会在页面返回这个json的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">"/getCity"</span>,<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    ctx.body = <span class="built_in">JSON</span>.parse(fs.readFileSync( <span class="string">'./static/city.json'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么问题来了，axios.get(“/api/user/getCity”)到底做了什么，导致vue拿到了数据呢？</p>
<p>缕一缕：</p>
<ol>
<li>首先在组件中使用axios调用接口</li>
<li>到vue.config.js中设置跨域。比如说当进入city页面时，请求了/api/user/getCity。那么在vue.config.js中所有/api开头的请求都会被转发至 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a> 这个地址。其实这个地址就是我们的koa2服务器。</li>
<li>此时，在组件中的请求变成了 <a href="http://localhost:3000/api/user/getCity" target="_blank" rel="noopener">http://localhost:3000/api/user/getCity</a> 。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">"/getCity"</span>,<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    ctx.body = <span class="built_in">JSON</span>.parse(fs.readFileSync( <span class="string">'./static/city.json'</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>koa2</category>
      </categories>
      <tags>
        <tag>webServer</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2实现session</title>
    <url>/2020/03/18/koa2%E5%AE%9E%E7%8E%B0session/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h1><blockquote>
<p>实现登录实际上就是要实现session。需要使用到两个插件： <strong>koa-generic-session</strong>和<strong>koa-redis</strong>。koa-redis也需要依赖基本的redis</p>
</blockquote>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cnpm install koa-generic-session koa-redis redis -S</span><br></pre></td></tr></table></figure>

<p>接下来开始在app.js中操作一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先引入两个下载好的插件。其实从官网可以看到这两个插件是同时使用的</span></span><br><span class="line"><span class="keyword">import</span> session <span class="keyword">from</span> <span class="string">'koa-generic-session'</span></span><br><span class="line"><span class="keyword">import</span> redisStore <span class="keyword">from</span> <span class="string">'koa-redis'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在写中间件的时候，要将代码写到注册路由之前</span></span><br><span class="line"><span class="comment">// session的配置</span></span><br><span class="line"><span class="comment">// 加密的key</span></span><br><span class="line">app.keys = [<span class="string">'LWJ#$1997'</span>]</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  <span class="comment">// 配置cookie</span></span><br><span class="line">  cookie:&#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    httpOnly: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// cookie有效期为一天</span></span><br><span class="line">    maxAge: <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>,</span><br><span class="line">    overwrite: <span class="literal">true</span>,</span><br><span class="line">    signed: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置redis</span></span><br><span class="line">  store:redisStore(&#123;</span><br><span class="line">    <span class="comment">// 先写死本地的redis ，这里应该根据配置环境不同而变化</span></span><br><span class="line">    all:<span class="string">"127.0.0.1:6379"</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>接下来做一个测试，看看是否成功</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">"/session-test"</span>,<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 因为在app.js中注册了session，所以这里应该有内容</span></span><br><span class="line">    <span class="keyword">if</span>(ctx.session.viewCount==<span class="literal">null</span>)&#123;</span><br><span class="line">        ctx.session.viewCount=<span class="number">0</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.session.viewCount++</span><br><span class="line"></span><br><span class="line">    ctx.body=&#123;</span><br><span class="line">        errno:<span class="number">0</span>,</span><br><span class="line">        viewCount:ctx.session.viewCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开redis-cli进行骚操作。可以看到成功了</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> 'keys' command</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) "koa:sess:W-c-<span class="number">7</span>RTc09iAXGCAdQW-<span class="number">2</span>wAnTIpq21bK"</span><br><span class="line"><span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; get koa:sess:W-c-<span class="number">7</span>RTc09iAXGCAdQW-<span class="number">2</span>wAnTIpq21bK</span><br><span class="line">"&#123;\"cookie\":&#123;\"<span class="built_in">path</span>\":\"/\",\"httpOnly\":true,\"maxAge\":<span class="number">86400000</span>,\"overwrite\":true,\"signed\":true&#125;,\"viewCount\":<span class="number">10</span>&#125;"</span><br></pre></td></tr></table></figure>

<p>既然成功了，那就说明现在不止可以存储viewCount，还可以存储username，password等等</p>
]]></content>
      <categories>
        <category>koa2</category>
      </categories>
      <tags>
        <tag>webServer</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2处理路由</title>
    <url>/2020/03/18/koa2%E5%A4%84%E7%90%86%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<ol>
<li>首先在routes文件夹下新建一个user.js文件</li>
<li>如下代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 因为koa2和koa-router是分离的，类似vue和vue-router。所以这里还需要引用一下</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给blog.js所有的路由添加一个前缀</span></span><br><span class="line"><span class="comment">// 比如下面的login，就需要通过/api/user/login访问</span></span><br><span class="line">router.prefix(<span class="string">"/api/user"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个login路由</span></span><br><span class="line">router.post(<span class="string">"/login"</span>,<span class="keyword">async</span>(ctx,next)=&gt;&#123;</span><br><span class="line">    <span class="comment">//通过ctx.request.body获取用户名密码</span></span><br><span class="line">    <span class="comment">//按理说ctx就包含了request，但是下面已经使用了ctx.body</span></span><br><span class="line">    <span class="comment">//为了做一个区分，就是用ctx.request.body</span></span><br><span class="line">    <span class="keyword">const</span> &#123;username,password&#125;=ctx.request.body</span><br><span class="line">    <span class="comment">//可以直接在页面上打印</span></span><br><span class="line">    ctx.body=&#123;</span><br><span class="line">        username,</span><br><span class="line">        password</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出router</span></span><br><span class="line"><span class="built_in">module</span>.exports=router</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>导出的router到app.js中要进行引用和注册，不然会NOT FOUND</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用</span></span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">'./routes/user'</span></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">app.use(user.routes(), user.allowedMethods())</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>到此路由的使用就差不多了</li>
</ol>
]]></content>
      <categories>
        <category>koa2</category>
      </categories>
      <tags>
        <tag>webServer</tag>
      </tags>
  </entry>
  <entry>
    <title>解决不能使用import</title>
    <url>/2020/03/18/%E8%A7%A3%E5%86%B3%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8import/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>在使用koa2时，将脚手架事先写好的代码改为es6的import会报错。表示cannot find module …..</p>
</blockquote>
<p>解决办法：</p>
<p>安装babel全家桶，因为现在还不熟悉babel。先这么着</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cnpm install @babel/cli @babel/core @babel/node @babel/runtime @babel/plugin-transform-runtime @babel/preset-env -D</span><br></pre></td></tr></table></figure>

<p>根目录创建 .babelrc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;@babel&#x2F;env&quot;],</span><br><span class="line">    &quot;plugins&quot;: [&quot;@babel&#x2F;plugin-transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一点需要注意，就是编译代码。意思是运行babelbiuld可以将src中的代码编译保存到dist中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "babelbuild": "babel src --out-dir dist"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>koa2</category>
      </categories>
      <tags>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2之环境搭建</title>
    <url>/2020/03/18/koa2%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<ol>
<li>全局安装</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cnpm install koa-generator -g</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用koa2初始化项目</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">koa2 koa-demo</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>安装插件</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="/images/19.png" alt=""></p>
<ol start="5">
<li>安装环境参数插件 cross-env</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">cnpm install cross-env -D</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>koa2</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之组件基础</title>
    <url>/2020/03/18/vue%E4%B9%8B%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h1><blockquote>
<p>要格外注意组件中的data是一个函数，而根实例的Vue是一个对象。并且data返回的是一个对象，要使用return</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h1><blockquote>
<p>可以任意次复用组件，要注意每个复用的组件都是独立的，即数据不会相互影响。因为每一个组件都会有一个它的新实例被创建</p>
</blockquote>
<h2 id="data-必须是一个函数"><a href="#data-必须是一个函数" class="headerlink" title="data 必须是一个函数"></a>data 必须是一个函数</h2><blockquote>
<p>之前一直到有这样的疑问，其实这样做的目的是为了让每一个被复用的组件都独立。因为当data为函数时才可以使用return。正因为此，每一个组件都可以维护自己的被返回的对象。</p>
</blockquote>
<h1 id="通过-Prop-向子组件传递数据"><a href="#通过-Prop-向子组件传递数据" class="headerlink" title="通过 Prop 向子组件传递数据"></a>通过 Prop 向子组件传递数据</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局创建一个组件名为blog-post</span></span><br><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">	<span class="comment">//有一个属性为title</span></span><br><span class="line">  props: [<span class="string">'title'</span>],</span><br><span class="line">  <span class="comment">//模板显示title属性值</span></span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在template中使用自定义的组件，并且有一个title属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Blogging with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Why Vue is so fun"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h1><h1 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h1><h2 id="使用事件抛出一个值"><a href="#使用事件抛出一个值" class="headerlink" title="使用事件抛出一个值"></a>使用事件抛出一个值</h2><h2 id="在组件上使用-v-model"><a href="#在组件上使用-v-model" class="headerlink" title="在组件上使用 v-model"></a>在组件上使用 v-model</h2><h1 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h1><h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><h1 id="解析-DOM-模板时的注意事项"><a href="#解析-DOM-模板时的注意事项" class="headerlink" title="解析 DOM 模板时的注意事项"></a>解析 DOM 模板时的注意事项</h1>]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue之事件处理</title>
    <url>/2020/03/18/vue%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h1><blockquote>
<p>不多赘述，看代码</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h1><blockquote>
<p>上面的事件的处理方法过于简单，但是绝大部分情况下都是复杂的逻辑，所以需要<strong>写在method中</strong>去调用。代码就不看了</p>
</blockquote>
<h1 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h1><blockquote>
<p>这是之前没有使用过的一种方法。在此之前都是直接绑定一个方法，但是其实还有一种就是直接调用它。</p>
</blockquote>
<p>可以发现每当被点击就调用say方法，并且会传入参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一种情况就是调用原始DOM事件，但是用的不多，以后再来补充</p>
<h1 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h1><blockquote>
<p>在Vue中提倡 method中只去处理数据的逻辑，而不是DOM事件。所以Vue提供了几个事件修饰符。有点难理解，以后用到在回来看看</p>
</blockquote>
<ul>
<li>.stop：用于阻止事件冒泡。具体什么意思呢?这需要了解JS的事件触发机制。看代码,可以发现他是嵌套的，如果点击最里面的div，那么事件会一直向上冒泡，将所有div都触发。但是使用了.stop后，再点击最里面的div，它外层的div也不会触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.stop</span>=<span class="string">"xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>.prevent：阻止默认事件的发生。假设有一个a标签，当你点击它后，就会自动跳转到href的网站，或者提交按钮，点击后会自动触发重新加载页面。但是如果使用了.prevent后，就会阻止默认事件的发生</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"xxxxxx"</span> @<span class="attr">click.prevent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>.capture：捕获冒泡，即有冒泡发生时，有该修饰符的dom元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件。</p>
</li>
<li><p>.self：将事件绑定到自身，只有自身才能触发，通常用于避免冒泡事件的影响</p>
</li>
<li><p>.once：设置事件只能触发一次，比如按钮的点击等。</p>
</li>
<li><p>.passive：该修饰符大概意思用于对DOM的默认事件进行性能优化，根据官网的例子比如超出最大范围的滚动条滚动的方法，可以使用该修饰符进行加强，但是效果并没有感觉到安静，如果有实际使用过的小伙伴可以留言补充。</p>
</li>
</ul>
<h1 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h1><blockquote>
<p>看文档，比较琐碎</p>
</blockquote>
<h1 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h1><h2 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h2><p>.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h2><p>.right   .middle  .left。这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue之列表渲染</title>
    <url>/2020/03/18/vue%E4%B9%8B%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="用-v-for-把一个数组对应为一组元素"><a href="#用-v-for-把一个数组对应为一组元素" class="headerlink" title="用 v-for 把一个数组对应为一组元素"></a>用 v-for 把一个数组对应为一组元素</h1><blockquote>
<p>现在回过头来看，这是之前开发的一个项目中用到的最多的指令了，但是从来没好好看过这里的文档，惭愧。</p>
</blockquote>
<p>顾名思义， v-for 可以访问父作用域的所有元素，并且能把数组对应成一组元素，然后去渲染，同时，还可以传入 index 参数，代表数组的下标。看代码</p>
<ul>
<li>这里的 parentMessage 就是父作用域中的元素，index 就是 items 数组的下标， item.message 就是数组中元素中的值</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: <span class="string">'Parent'</span>,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>还需要注意， v-for 中可以使用 item of items 的形式，因为 of 更贴近 JS 迭代器语法</strong></p>
<h1 id="在-v-for-里使用对象"><a href="#在-v-for-里使用对象" class="headerlink" title="在 v-for 里使用对象"></a>在 v-for 里使用对象</h1><blockquote>
<p>上面说了，v-for 是把一个数组对应成一组元素去循环的指令。这里却使用对象，怎么操作呢？其实使用方法也是一样的，但是也会有一定的差异</p>
</blockquote>
<p>先看个例子。可以发现这儿居然有三个参数！</p>
<ul>
<li>value：object的value值</li>
<li>name：object的key值</li>
<li>index：最骚的是object的索引值</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, name, index) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#v-for-object'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      title: <span class="string">'How to do lists in Vue'</span>,</span><br><span class="line">      author: <span class="string">'Jane Doe'</span>,</span><br><span class="line">      publishedAt: <span class="string">'2016-04-10'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h1><blockquote>
<p>维护状态？wtf！ 又是不好理解的名词，直接看代码吧</p>
</blockquote>
<p>可以发现这不就是使用过的key值吗？之前只知道 v-for 后面必须去使用 :key=”别名.id”。现在来好好理解一下为什么</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先需要理解一个概念：<strong>就地更新策略</strong>。啥意思呢？即当去更新一个使用了 v-for 循环的列表时，如果有元素顺序发生了改变，vue是不会去根据顺序的不同而去移动dom，而是直接更新不同的元素。在vue文档说这是一个高效的模式。这里又是一串令人摸不着头脑的话：<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。</strong> 但是不用深究，了解即可。更重要的是 key 的使用。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性<strong>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</strong>这也解释了为什么要给数据加上id，因为id是数值</p>
<h1 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h1><h2 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h2><blockquote>
<p>顾名思义，即变异方法会对原数组产生影响，说白了就是在原数组上操作，基于此，这样会直接触发视图的更新（因为v-for是基于数组而去循环的）</p>
</blockquote>
<p>那么有哪儿些呢？</p>
<ul>
<li><p>push：在数组末尾添加值</p>
</li>
<li><p>pop：在数组末尾删除值</p>
</li>
<li><p>shift：在数组开头删除值</p>
</li>
<li><p>unshift：在数组开头添加值</p>
</li>
<li><p>splice：这个比较复杂，它有三个参数：splice(index，delete num，add element)。等下举个例子</p>
</li>
<li><p>sort：排序。等下举个例子</p>
</li>
<li><p>reverse：颠倒</p>
</li>
<li><p>splice</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> months = [<span class="string">'Jan'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'June'</span>];</span><br><span class="line"><span class="comment">// 从数组索引为1的元素开始，即March。然后删除0个元素，然后在此添加Feb元素</span></span><br><span class="line"><span class="comment">// 即原数组被修改为["Jan", "Feb", "March", "April", "June"]</span></span><br><span class="line">months.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'Feb'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>sort</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="keyword">var</span> numbers = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>];</span><br><span class="line">numbers.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a) <span class="comment">// [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>reverse</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1, 2, 3]</span></span><br><span class="line">a.reverse(); </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<h2 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h2><blockquote>
<p>与变异数组相对应的就是替换数组了，即不会改变原数组，而是生成一个新的数组。那么就需要将原数组替换掉以触发视图的更新。现在可能会担心这样会影响性能，因为替换掉整个数组就得重新去渲染。但是vue使用了某种方式，使得<strong>具有相同元素的数组的替换变得高效。</strong></p>
</blockquote>
<p>常用的几个方法：</p>
<ul>
<li>filter：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">'spray'</span>, <span class="string">'limit'</span>, <span class="string">'elite'</span>, <span class="string">'exuberant'</span>, <span class="string">'destruction'</span>, <span class="string">'present'</span>];</span><br><span class="line"><span class="comment">// 给filter传入一个函数，然后取出所有的元素(word)进行比较(word.length &gt; 6)</span></span><br><span class="line"><span class="keyword">const</span> result = words.filter(<span class="function"><span class="params">word</span> =&gt;</span> word.length &gt; <span class="number">6</span>); </span><br><span class="line"><span class="comment">// Array ["exuberant", "destruction", "present"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>concat：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"><span class="comment">// 将两个数组进行拼接</span></span><br><span class="line"><span class="keyword">const</span> array3 = array2.concat(array1);</span><br><span class="line"><span class="comment">// Array ["d", "e", "f", "a", "b", "c"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>slice：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animals = [<span class="string">'ant'</span>, <span class="string">'bison'</span>, <span class="string">'camel'</span>, <span class="string">'duck'</span>, <span class="string">'elephant'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对原数组从第二个开始（index为2的camel）进行拷贝</span></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck", "elephant"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对原数组从第二个开始（index为2的camel）到第四个为止（index为4的elephant）但不包括第四个进行拷贝</span></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["camel", "duck"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对原数组从第一个开始（index为1的bison）到第五个为止（index为5不存在）但不包括第五个进行拷贝</span></span><br><span class="line"><span class="built_in">console</span>.log(animals.slice(<span class="number">1</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// expected output: Array ["bison", "camel", "duck", "elephant"]</span></span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote>
<p>当直接想<strong>通过索引添加一个元素</strong>时或者想<strong>修改数组长度以达到不可告人的目的</strong>时，都可以通过 splice 来实现！所以要对splice方法烂熟于心</p>
</blockquote>
<ol>
<li>在数组索引为2的地方添加元素edison：splice( 2, 0, edison )</li>
<li>将数组长度设置为3（原数组长度为5）：splice( 3 )  。这里意思其实就是从索引为3的元素开始全部删除</li>
</ol>
<h1 id="对象变更检测注意事项"><a href="#对象变更检测注意事项" class="headerlink" title="对象变更检测注意事项"></a>对象变更检测注意事项</h1><blockquote>
<p>和上面所说的数组某些情况一样，对象也不能响应式的添加属性，需要用到 Vue.set</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Vue.set(Object,propertyName,value)</span></span><br><span class="line"><span class="comment">// 意思是想根实例data对象添加b属性名和他的值2</span></span><br><span class="line">Vue.set(vm.data,<span class="string">"b"</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的情况是添加一个，但是如果要添加多个呢？注意要使用<strong>Object.assign() 或者 _.extend()</strong></p>
</blockquote>
<p>你肯定觉得应该这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(vm.data,&#123;</span><br><span class="line">	b:<span class="number">2</span>,</span><br><span class="line">	c:<span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>先来看看 Object.assign() 如何使用：它传入两个对象参数，target和source。意思是将source对象传入到target。<strong>用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</strong>举个栗子。这样一看，上面写法应该没错。但实际是错的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<p>正确写法：其实很好理解，将vm.data和将要插入的新属性都合并到一个空的对象中，然后将其赋值给vm.data。（这里从MDN看到的）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.data=<span class="built_in">Object</span>.assign(&#123;&#125;,vm.data,&#123;</span><br><span class="line">	b:<span class="number">2</span>,</span><br><span class="line">	c:<span class="number">3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h1 id="显示过滤-排序后的结果"><a href="#显示过滤-排序后的结果" class="headerlink" title="显示过滤/排序后的结果"></a>显示过滤/排序后的结果</h1><blockquote>
<p>有时候，想显示一个经过排序或者过滤后的结果，但是不对原始数据产生影响。其实这里就需要用到之前说的替换数组如 filter、concat、slice。</p>
</blockquote>
<ul>
<li>使用计算属性</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 因为evenNumbers为函数，也就是一个对象，所以使用 in 而不是 of</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">	numbers:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line">computed:&#123;</span><br><span class="line">	evenNumbers()=&gt;&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="params">number</span>=&gt;</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以使用method！</p>
<h1 id="在-v-for-里使用值范围"><a href="#在-v-for-里使用值范围" class="headerlink" title="在 v-for 里使用值范围"></a>在 v-for 里使用值范围</h1><blockquote>
<p>amazing，这个还没看到过！  其实就是不借助根实例的data就可以循环</p>
</blockquote>
<p>最后会显示1到10</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="在模板上使用-v-for"><a href="#在模板上使用-v-for" class="headerlink" title="在模板上使用 v-for"></a>在模板上使用 v-for</h1><blockquote>
<p>和 v-if 一样，v-for 同样可以用于循环一个模板，即多个标签元素</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span> <span class="attr">role</span>=<span class="string">"presentation"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="v-for-与-v-if-一同使用"><a href="#v-for-与-v-if-一同使用" class="headerlink" title="v-for 与 v-if 一同使用"></a>v-for 与 v-if 一同使用</h1><blockquote>
<p>反正别这么用就ok</p>
</blockquote>
<h1 id="在组件上使用-v-for"><a href="#在组件上使用-v-for" class="headerlink" title="在组件上使用 v-for"></a>在组件上使用 v-for</h1><blockquote>
<p>这里详细看<strong>深入组件</strong>即可</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue之条件渲染</title>
    <url>/2020/03/16/vue%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h1><blockquote>
<p>v-if的作用是字面意思，即条件为真则显示，反之不显示</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"awesome"</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>假设这里awesome为false，那么h1就不会显示，如果加个else就不一样了，反之逻辑就是这样！</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"awesome"</span>&gt;</span>Vue is awesome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>Oh no 😢<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="在模板（template）元素上使用-v-if-条件渲染分组"><a href="#在模板（template）元素上使用-v-if-条件渲染分组" class="headerlink" title="在模板（template）元素上使用 v-if 条件渲染分组"></a>在模板（template）元素上使用 v-if 条件渲染分组</h2><blockquote>
<p>因为v-if是一个指令，所以必须用在元素上。那就说明只能控制一个元素的显示与否。事实果真如此吗？</p>
</blockquote>
<p>其实只需要在外层包裹一个不可见的template元素即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h2><blockquote>
<p>这里上面已经使用过，这里说一点，即<strong>v-else必须跟在v-if 或者 v-else-if 后面，否则不会生效</strong></p>
</blockquote>
<h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><blockquote>
<p>同 v-else 一样。 不在过多赘述</p>
</blockquote>
<h2 id="用key管理可复用的元素"><a href="#用key管理可复用的元素" class="headerlink" title="用key管理可复用的元素"></a>用key管理可复用的元素</h2><blockquote>
<p>顾名思义，当添加key值时，被添加的元素不会被复用，反之则会被服用。看下面代码理解</p>
</blockquote>
<p>不使用key，你所填写的东西也会被服用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用key，所填写的东西不会被服用，但是要牢记，例如 label ，它并没有key值，所以还是会被复用。实际上vue很快的原因有一部分在于此。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h1><blockquote>
<p>v-show 用法和 v-if大致相当，但是有几点不同。<strong>一个是v-show控制元素显示与否的方法是给元素添加了一个css属性，display none 。  v-if是直接消灭掉别隐藏的dom ；另一个是 v-show 没有 v-if的逻辑块；最后一个是没有template，即不可以同时控制多个元素</strong></p>
</blockquote>
<h1 id="v-if-VS-v-show"><a href="#v-if-VS-v-show" class="headerlink" title="v-if VS v-show"></a>v-if VS v-show</h1><blockquote>
<p>在介绍了v-show的基本原理后就会有一个问题，即何时使用v-if或者v-show？</p>
</blockquote>
<p>总结一下：</p>
<ul>
<li>v-if 在页面初始时会根据条件值去判断是否该去渲染，所以这会造成<strong>切换</strong>时的开销</li>
<li>v-show 在页面初始时无论如何都会渲染，所以这会造成<strong>启动</strong>页面时的开销。</li>
<li>在一个组件或者元素需要被频繁切换（即改变条件，下同）时，就使用 v-show 。因为它只需要改变css即可</li>
<li>在一个组件或者元素很少被切换时，就使用v-if</li>
</ul>
<h1 id="v-if-和-v-for一起使用"><a href="#v-if-和-v-for一起使用" class="headerlink" title="v-if 和 v-for一起使用"></a>v-if 和 v-for一起使用</h1><blockquote>
<p><strong>不推荐使用。</strong>因为 v-for 的优先级比 v-if 更高</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue之类与样式</title>
    <url>/2020/03/16/vue%E4%B9%8B%E7%B1%BB%E4%B8%8E%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h1><blockquote>
<p>操作元素的class列表和内联样式是数据绑定的常见需求。又因为都是属性，所以可以使用v-bind。并且这里v-bind不仅可以使用JS表达式，还可以使用对象或者数组</p>
</blockquote>
<h2 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h2><p>最常见的例子,表示active受到isActive的控制。即isActive为true，则class为active。反之则没有class属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，不仅仅只能写一个class。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后被渲染为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有另外一种样式，因为上面这样写html实在是太丑太不美观了。所以可以将<strong>{ active: isActive, ‘text-danger’: hasError }</strong>抽象出来写为<strong>{classObject}</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">"&#123; classObject &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">	classObject:&#123;</span><br><span class="line">		active: <span class="literal">true</span>, </span><br><span class="line">		<span class="string">'text-danger'</span>: <span class="literal">false</span> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅如此，还可以改写为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data:&#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">computed:&#123;</span><br><span class="line">	classObject()&#123;</span><br><span class="line">	<span class="comment">//返回两个类</span></span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      		<span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h2><p>基本例子理解就好，不深究了，用的时候再来看</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass, errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue之计算属性&amp;侦听器</title>
    <url>/2020/03/16/vue%E4%B9%8B%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7&amp;%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><blockquote>
<p>设计模板表达式的初衷是为了简化计算，但是随着业务的深入，这里的代码就会变得复杂难以维护。代码如下：</p>
</blockquote>
<p>首先模板从vue实例中拿到message，然后进行一系列的操作。第一感觉就是很烦不简洁</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么如何处理呢？按照文档的话来说：<strong>处理任何复杂逻辑的运算都应该被放在计算属性中</strong></p>
<h2 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h2><blockquote>
<p>已经有过了解了，所以直接上代码。可以发现一个之前没有注意过的细节。就是Mustache中不只是可以放data属性里的东西，computed计算属性也可以。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="computed-VS-method"><a href="#computed-VS-method" class="headerlink" title="computed VS method"></a>computed VS method</h2><blockquote>
<p>其实上面的例子也可以写在method中，那么有什么不同呢？</p>
</blockquote>
<p>computed：计算属性是依赖于data里面属性的变化而变化的。而他们又是响应式的，所以只要data不变，那么computed的值也就不变。所以在vue中，computed的值被<strong>缓存</strong>了下来。只要data不变，不论这个计算属性调用多少次，都会立即返回结果。即只在第一次被调用或者data改变时才会进行计算。</p>
<p>method：只要页面被渲染，method总会重新进行计算。</p>
<blockquote>
<p>所以可以明确，如果希望有缓存并且计算量大的话，就使用computed。反之则使用method</p>
</blockquote>
<h2 id="computed-VS-watch"><a href="#computed-VS-watch" class="headerlink" title="computed VS watch"></a>computed VS watch</h2><blockquote>
<p>这个不深究，之前写过一篇文章解释。文档核心意思就是，不要滥用watch</p>
</blockquote>
<h2 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h2><blockquote>
<p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p>
</blockquote>
<p>现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h1 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h1><blockquote>
<p>虽然computed能满足大部分情况，但是<strong>需要在数据发生变化时进行异步操作或开销较大的运算时，就需要使用watch</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vue之模板语法</title>
    <url>/2020/03/16/vue%E4%B9%8B%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>开始复习vue的基础知识，为了后续做准备</p>
</blockquote>
<blockquote>
<p>vue.js使用了基于html模板语法，并且能声明式的将dom绑定至底层vue的实例上的数据。在底层的实现上，又将这些模板语法编译为虚拟dom渲染函数。</p>
</blockquote>
<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><h2 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h2><blockquote>
<p>数据绑定的最常见的形式就是使用Mustache语法，在之前学的ejs模板语法也是使用的Mustache。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里的msg对应的是vue实例上对应的msg数据，他会响应式的变化，即vue实例中msg数据变化了，html中的插值也会变化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>既然会响应式的变化，那么肯定会有一个需求就是不想让他响应式，即只变化一次。可以使用v-once指令</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="原始html"><a href="#原始html" class="headerlink" title="原始html"></a>原始html</h2><blockquote>
<p>什么意思呢？通过上面可知一二。能发现vue的Mustache是将数据解释为文本，但是有时候想直接上去丢一段html代码怎么办呢？可以使用<strong>v-html</strong>指令</p>
</blockquote>
<p><strong>但是要注意，这种很容易遭受xss攻击。所以不要对用户提供这种功能</strong></p>
<blockquote>
<p>当然还有<strong>JS表达式</strong>和<strong>Attribute</strong>的用法，这里不深究，用的多就懂了</p>
</blockquote>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><blockquote>
<p>指令是带有<strong>v-</strong>前缀的特殊attribute。一般来说，指令的值的预期都是单个JS表达式，但是v-for是例外的。因为v-for都是用来循环组件输出，需要写循环语句，例如（item of items）、并且还与:key连用。这里不多讲了。 </p>
</blockquote>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><blockquote>
<p>有一些指令可以通过冒号后面接一个参数名。</p>
</blockquote>
<p>这句话的意思就是告知v-bind指令将href和url值绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可能上面的现在看不出有啥卵用，但是下面的一定就懂了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"eventFun"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h2><blockquote>
<p><strong>文档：可以用方括号括起来的 JavaScript 表达式作为一个指令的参数</strong></p>
</blockquote>
<blockquote>
<p>看着文档挺复杂，先看个代码。但是核心意思就<strong>方括号</strong>里面的attributeName是一个动态的，即可变的。具体点，就是说这个动态的参数可以被vue实例中data中的attributeName的值所改变</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">"url"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h1><h2 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">"url"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">"doSomething"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>BFC（Block Formatting Context）</title>
    <url>/2020/03/13/BFC%EF%BC%88Block-Formatting-Context%EF%BC%89/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote>
<p>BFC中文意思为块级格式化上下文。在张鑫旭的书中是这样描述的：<strong>如果一个元素具有BFC，那么内部的子元素不管怎么翻江倒海、翻云覆雨，都不会影响外界的变化。</strong></p>
</blockquote>
<p>那么基于上面的话可以得出两个结论：</p>
<ul>
<li>具有BFC的元素是不可能发生margin的重叠，因为margin重叠势必影响布局</li>
<li>具有BFC的元素可以用来清除浮动，因为浮动会对布局产生影响，例如高度塌陷</li>
</ul>
<h2 id="触发BFC的情况"><a href="#触发BFC的情况" class="headerlink" title="触发BFC的情况"></a>触发BFC的情况</h2><ul>
<li>html根元素</li>
<li>float的值不为none</li>
<li>overflow的值为auto、scrool、hidden（重要）</li>
<li>display的值为table-cell（重要）、table-caption、inline-block（重要）</li>
<li>position的值为absolut、fixed、sticky</li>
</ul>
<p><strong>换言之，假如有元素符合上面的BFC触发条件，就不用在写clear：both；</strong></p>
<h1 id="BFC与流体布局"><a href="#BFC与流体布局" class="headerlink" title="BFC与流体布局"></a>BFC与流体布局</h1><blockquote>
<p><strong>实际上，BFC的结界特性最重要的用途并非去除margin重叠或者清除float浮动，而是实现更加健壮、智能的自适应布局。</strong></p>
</blockquote>
<p>有如下代码已经显示效果。可以发现文字已经受到img标签浮动的影响产生了环绕。那么如何清除浮动呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.father</span>&#123;</span></span><br><span class="line">			width: 200px;</span><br><span class="line"><span class="css">			<span class="selector-tag">height</span><span class="selector-pseudo">:200px</span></span></span><br><span class="line">		&#125;</span><br><span class="line">		img&#123;</span><br><span class="line">			width: 100px;</span><br><span class="line"><span class="css">			<span class="comment">/* float影响了子元素 */</span></span></span><br><span class="line">			float: left;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://www.bing.com/th?id=OHR.FrenchColorado_ZH-CN9446885520_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=HpEdgeAn"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"animal"</span>&gt;</span>猫、狗、狮子、猫、狗、狮子、猫、狗、狮子<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/17.png" alt=""></p>
<p>使用 overflow：hidden 即可。其实还有一种解决办法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animal</span>&#123;</span><br><span class="line"> 	<span class="comment">/* overflow: auto; */</span></span><br><span class="line"> 	<span class="attribute">display</span>: table-cell;</span><br><span class="line"> 	<span class="comment">/* 无论宽度设置的 */</span></span><br><span class="line"> 	<span class="attribute">width</span>: <span class="number">9999px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/18.png" alt=""></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Virtual DOM</title>
    <url>/2020/03/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Virtual-DOM/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="what’s-virtual-DOM"><a href="#what’s-virtual-DOM" class="headerlink" title="what’s virtual DOM ?"></a>what’s virtual DOM ?</h1><blockquote>
<p>顾名思义，virtual dom即使用JS模拟的一个dom结构，而不是真正的html绘制的dom。听起来可能有点儿绕，举个例子。假设现在有3个dom：a b c。但是现在想删除b，传统怎么做的呢？把abc全干掉，然后插入ac。virtual dom是直接干掉b，不会对ac做任何操作。这样比起来virtual dom简直效率太高了。提高了页面的重绘性能。</p>
</blockquote>
<p>看个栗子：是不是些virtual dom很麻烦？但是要牢记，浏览器最耗费性能的是dom操作！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dom：</span></span><br><span class="line"><span class="comment">// &lt;ul id="x"&gt;</span></span><br><span class="line"><span class="comment">// 	&lt;li class="y"&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">// 	&lt;li class="z"&gt;2&lt;/li&gt;</span></span><br><span class="line"><span class="comment">// &lt;/ul&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用js模拟这个dom</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//ul标签</span></span><br><span class="line">	tag:<span class="string">"ul"</span></span><br><span class="line">	<span class="comment">//ul标签的id属性值</span></span><br><span class="line">	attrs:&#123;</span><br><span class="line">		id:<span class="string">"x"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//ul标签下的子标签</span></span><br><span class="line">	children:[</span><br><span class="line">		&#123;</span><br><span class="line">			tag:<span class="string">"li"</span>,</span><br><span class="line">			attrs:&#123;</span><br><span class="line">				<span class="comment">// 这里为什么不用class呢？因为class是JS的保留字</span></span><br><span class="line">				className:<span class="string">"y"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">//里面的文本</span></span><br><span class="line">			children:[<span class="string">"1"</span>]</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			tag:<span class="string">"li"</span>,</span><br><span class="line">			attrs:&#123;</span><br><span class="line">				className:<span class="string">"z"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">//里面的文本</span></span><br><span class="line">			children:[<span class="string">"2"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Why-does-Virtual-Dom-exist"><a href="#Why-does-Virtual-Dom-exist" class="headerlink" title="Why does Virtual Dom exist ?"></a>Why does Virtual Dom exist ?</h1><blockquote>
<p>其实这个问题在上面已经回答了，做个总结</p>
</blockquote>
<ol>
<li>DOM操作非常“expensive”，使用js效率会更高</li>
<li>尽量可以精准打击，而不是推倒重来</li>
<li>DOM操作项目越复杂，影响就越严重</li>
</ol>
<h1 id="how-to-use"><a href="#how-to-use" class="headerlink" title="how to use ?"></a>how to use ?</h1><blockquote>
<p>virtual dom实际上只是一个标准，或者说是实现这种功能的统称。比如vue、react实现virtual dom的技术都是不一样的，但是解决的问题都是出不多的</p>
</blockquote>
<h2 id="snabbdom"><a href="#snabbdom" class="headerlink" title="snabbdom"></a>snabbdom</h2><p>来看一个流行的开源virtual dom库：snabbdom</p>
<p>官方例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> snabbdom = <span class="built_in">require</span>(<span class="string">'snabbdom'</span>);</span><br><span class="line"><span class="keyword">var</span> patch = snabbdom.init([ <span class="comment">// 使用选中的模块初始化patch函数</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'snabbdom/modules/class'</span>).default, <span class="comment">// 使切换类变得容易</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'snabbdom/modules/props'</span>).default, <span class="comment">// 用于设置DOM元素的属性</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'snabbdom/modules/style'</span>).default, <span class="comment">// 处理带有动画支持的元素样式</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'snabbdom/modules/eventlisteners'</span>).default, <span class="comment">// 事件监听器</span></span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> h = <span class="built_in">require</span>(<span class="string">'snabbdom/h'</span>).default; <span class="comment">// 用于创建virtual node的辅助函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以读到现在，实际上snabbdom最主要的两个函数就是 patch &amp; h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 id 为 container 的dom。注意，此刻为空容器</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以发现 vnode 是使用 h 创建的</span></span><br><span class="line"><span class="comment">// h的参数为： h("dom's id or class or element",&#123;css styles&#125;,[children or innerhtml])</span></span><br><span class="line"><span class="keyword">var</span> vnode = h(<span class="string">'div#container.two.classes'</span>, &#123;<span class="attr">on</span>: &#123;<span class="attr">click</span>: someFn&#125;&#125;, [</span><br><span class="line">  h(<span class="string">'span'</span>, &#123;<span class="attr">style</span>: &#123;<span class="attr">fontWeight</span>: <span class="string">'bold'</span>&#125;&#125;, <span class="string">'This is bold'</span>),</span><br><span class="line">  <span class="string">' and this is just normal text'</span>,</span><br><span class="line">  h(<span class="string">'a'</span>, &#123;<span class="attr">props</span>: &#123;<span class="attr">href</span>: <span class="string">'/foo'</span>&#125;&#125;, <span class="string">'I\'ll take you places!'</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// Patch into empty DOM element – this modifies the DOM as a side effect</span></span><br><span class="line"><span class="comment">// 这句话不太会翻译，应该是patch插入到空的dom节点-这是修改dom的副作用？</span></span><br><span class="line"><span class="comment">// 看了下面的patch，才发现这个意思是将vnode插入到名为container的空容器中，即修改containner的dom为vnode</span></span><br><span class="line">patch(container, vnode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newVnode = h(<span class="string">'div#container.two.classes'</span>, &#123;<span class="attr">on</span>: &#123;<span class="attr">click</span>: anotherEventHandler&#125;&#125;, [</span><br><span class="line">  h(<span class="string">'span'</span>, &#123;<span class="attr">style</span>: &#123;<span class="attr">fontWeight</span>: <span class="string">'normal'</span>, <span class="attr">fontStyle</span>: <span class="string">'italic'</span>&#125;&#125;, <span class="string">'This is now italic type'</span>),</span><br><span class="line">  <span class="string">' and this is still just normal text'</span>,</span><br><span class="line">  h(<span class="string">'a'</span>, &#123;<span class="attr">props</span>: &#123;<span class="attr">href</span>: <span class="string">'/bar'</span>&#125;&#125;, <span class="string">'I\'ll take you places!'</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 第二次调用patch</span></span><br><span class="line">patch(vnode, newVnode); <span class="comment">// Snabbdom有效地将旧视图更新为新状态，将vnode替换成newVnode</span></span><br></pre></td></tr></table></figure>

<h1 id="simple-to-understand-the-diff-Algorithm"><a href="#simple-to-understand-the-diff-Algorithm" class="headerlink" title="simple to understand the diff Algorithm"></a>simple to understand the diff Algorithm</h1><blockquote>
<p>简单了解一下</p>
</blockquote>
<h2 id="what’s-diff-algorithm"><a href="#what’s-diff-algorithm" class="headerlink" title="what’s diff algorithm?"></a>what’s diff algorithm?</h2><blockquote>
<p>实际上就是比较两个文件在内容上有什么不同</p>
</blockquote>
<h2 id="why-use-diff-algorithm"><a href="#why-use-diff-algorithm" class="headerlink" title="why use diff algorithm?"></a>why use diff algorithm?</h2><blockquote>
<p>Because dom is very expensive to manipulate，所以需要找到不同点，所以这也是为什么需要diff算法的原因</p>
</blockquote>
<h2 id="the-realization-of-the-diff"><a href="#the-realization-of-the-diff" class="headerlink" title="the realization of the diff"></a>the realization of the diff</h2><blockquote>
<p>根据前面的snabbdom，有两个核心api：h 和 patch。这里只讲patch</p>
</blockquote>
<p>patch的两种用法</p>
<ol>
<li>patch(container,vnode)  这里只关心vnode（即虚拟的dom）是如何生成为真实的dom的</li>
<li>patch(vnode,newNode) 要找出两种区别，然后新增或者减少dom</li>
</ol>
<h3 id="patch-container-vnode"><a href="#patch-container-vnode" class="headerlink" title="patch(container,vnode)"></a>patch(container,vnode)</h3><p>直接上代码，vnode使用上面定义的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">vnode</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> tag=vnode.tag</span><br><span class="line">	<span class="comment">// 要注意attrs是element的id或者class   是可以为空的</span></span><br><span class="line">	<span class="keyword">let</span> attrs=vnode.attrs || &#123;&#125;</span><br><span class="line">	<span class="comment">// 这里同上</span></span><br><span class="line">	<span class="keyword">let</span> children=vnode.children || []</span><br><span class="line">	<span class="comment">// 判断是否传入了有效的vnode</span></span><br><span class="line">	<span class="keyword">if</span>(!tag)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">	<span class="comment">// 开始</span></span><br><span class="line">	<span class="comment">// 创建一个节点</span></span><br><span class="line">	<span class="keyword">let</span> elem=<span class="built_in">document</span>.createElement(tag)</span><br><span class="line">	<span class="comment">// 创建属性</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> attrName <span class="keyword">in</span> attrs)&#123;</span><br><span class="line">		<span class="keyword">if</span>(attrs.hasOwnProperty(attrName))&#123;</span><br><span class="line">			elem.setAttributes(attrName,attrs[attrName])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 创建子元素</span></span><br><span class="line">	children.forEach(<span class="function"><span class="params">childVnode</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">// 关键来了，递归！！！createElement(childVnode)再次调用这个函数</span></span><br><span class="line">		<span class="comment">// 递归说白了就是自己调用自己</span></span><br><span class="line">		<span class="comment">// 这里childVnode是children的元素，即一个对象，所以能使用递归（因为createElement需要传入一个对象）</span></span><br><span class="line">		elem.appendChild(createElement(childVnode))</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 返回这个元素dom</span></span><br><span class="line">	<span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h4><blockquote>
<p>for in是用来遍历对象的，但是不太熟悉，这里在熟悉一下，因为上面的算法用到了</p>
</blockquote>
<p>官方解释：<strong>for…in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）</strong></p>
<p>看个例子</p>
<p>数组：可以发现在遍历数组时，i表示的是每个元素的下标</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> a)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);<span class="comment">//0 1 2</span></span><br><span class="line">	<span class="built_in">console</span>.log(a[i]);<span class="comment">//1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象：可以发现在遍历对象时，i是对象的key。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">	x:<span class="number">1</span>,</span><br><span class="line">	y:<span class="number">2</span>,</span><br><span class="line">	z:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> a)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);<span class="comment">//x y z</span></span><br><span class="line">	<span class="built_in">console</span>.log(a[i]);<span class="comment">//1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h4><blockquote>
<p>for of  是在 for in 之后推出的，那就有意思了，先来看看for of能干什么</p>
</blockquote>
<p>数组：可以发现i现在是数组的值了，不在是下标</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> a)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);<span class="comment">//1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象：怎么是不是觉得i现在变成了对象的value？<strong>oops~  大错特错，因为for of不支持数组！所以这种用法是错误的</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">	x:<span class="number">1</span>,</span><br><span class="line">	y:<span class="number">2</span>,</span><br><span class="line">	z:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> a)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);</span><br><span class="line">	<span class="built_in">console</span>.log(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote>
<p>所以，根据代码，for in之后，attrName表示的是标签的class值或者id值。在提取出attrName后，在通过hasOwnProperty进行判断attrName是否为attr的自有属性，如果判断为真，就为elem创建这个属性</p>
</blockquote>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><blockquote>
<p>forEach() 方法对数组的每个元素执行一次提供的函数。</p>
</blockquote>
<p>写到这里其实突然想起来一个事儿，就是之前在面试的时候，碰到一个题目。结构跟下面代码差不多，具体忘了。但是肯定是要用到递归的，当时就觉得z里面嵌套了n（未知）层，就觉得很难搞，就凉在这儿了。哎其实就是递归的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">	x:<span class="number">1</span>,</span><br><span class="line">	y:<span class="number">1</span>,</span><br><span class="line">	z:[</span><br><span class="line">		&#123;</span><br><span class="line">			x:<span class="number">2</span>,</span><br><span class="line">			y:<span class="number">2</span>,</span><br><span class="line">			z:[</span><br><span class="line">				&#123;</span><br><span class="line">					x:<span class="number">3</span>,</span><br><span class="line">					y:<span class="number">3</span></span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> children=a.z</span><br><span class="line"><span class="built_in">console</span>.log(children)<span class="comment">//[ &#123; x: 2, y: 2, z: [ [Object] ] &#125; ]</span></span><br><span class="line">children.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(item)<span class="comment">//&#123; x: 2, y: 2, z: [ &#123; x: 3, y: 3 &#125; ] &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="patch-vnode-newNode"><a href="#patch-vnode-newNode" class="headerlink" title="patch(vnode,newNode)"></a>patch(vnode,newNode)</h3><p>这里只考虑最简单的情况:子节点被修改，并且新增了一个子节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">vnode,newVnode</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//首先将两个子节点都拿出来</span></span><br><span class="line">	<span class="keyword">let</span> children=vnode.children || []</span><br><span class="line">	<span class="keyword">let</span> newChildren=newVnode.children || []</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历现有的vnode</span></span><br><span class="line">	<span class="comment">//index为forEach的可选参数，即当前元素的索引</span></span><br><span class="line">	children.forEach(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//遍历新的vnode</span></span><br><span class="line">		<span class="keyword">let</span> newChild=newChildren[index]</span><br><span class="line">		<span class="comment">//如果不存在</span></span><br><span class="line">		<span class="keyword">if</span>(newChild==<span class="literal">null</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="comment">//如果旧的vnode的tag等于新的,就递归</span></span><br><span class="line">		<span class="keyword">if</span>(item.tag===newChild.tag)&#123;</span><br><span class="line">			updateChildren(item,newChild)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JS异步</title>
    <url>/2020/03/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>学到这个阶段也就是查漏补缺应对面试了，项目相反可以放一放，唯一遗憾的是之前花那么多时间做项目却没有好好边做边总结，这是一大误区。这篇文章将深入理解JS中的异步，包括几个面试题，又通过面试题牵引出更多知识点。</p>
</blockquote>
<h1 id="什么是单线程，和异步有什么关系？"><a href="#什么是单线程，和异步有什么关系？" class="headerlink" title="什么是单线程，和异步有什么关系？"></a>什么是单线程，和异步有什么关系？</h1><h2 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h2><blockquote>
<p>自我理解就是单行道，不能超车，只能一个接着一个，如果有一辆车熄火，那么后面所有的车都得等待，这就会导致堵塞，在程序中也是一样的道理。</p>
<p>异步的话还是这个场景，但是现在是双行道或者更多，尽管出口还是单行道。但是却有了质的改变，如果车熄火了，那么就把这辆车移动到非主干道上，后面的车不会因为它而堵塞。当这辆车修好后，就继续回到路上。</p>
</blockquote>
<h3 id="JS为什么要设计成单线程？"><a href="#JS为什么要设计成单线程？" class="headerlink" title="JS为什么要设计成单线程？"></a>JS为什么要设计成单线程？</h3><blockquote>
<p>这是因为js起初只是一个脚本语言，用来配合浏览器工作，而浏览器又涉及到DOM的渲染，并且JS也可以操作DOM，所以在JSJ执行的时候，DOM渲染会暂停。可以预见，假如又执行JS，并且浏览器还在渲染DOM就很可能出错。上面说的是JS和浏览器，那么JS与JS呢？如果两端JS都操作同一个DOM，那么肯定会出错，所以JS为了避免DOM渲染冲突出错，就设计成了单线程</p>
</blockquote>
<h4 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h4><blockquote>
<p>了解即可，但是并不能代替异步</p>
</blockquote>
<blockquote>
<p>web worker 设计来就是要让浏览器一直运行良好，如果不让主线程先执行，你web worker 计算量大还是会卡死浏览器。那么有没有web worker 都没有什么区别了</p>
</blockquote>
<h1 id="什么是event-loop-？"><a href="#什么是event-loop-？" class="headerlink" title="什么是event-loop ？"></a>什么是event-loop ？</h1><blockquote>
<p>event-loop是JS异步的具体解决方案，先执行所有的函数，如果是同步函数就直接执行，遇到异步函数就放入到异步队列中，当所有的同步函数都执行完了，在开始event-loop异步函数</p>
</blockquote>
<h2 id="理解-event-loop工作流程"><a href="#理解-event-loop工作流程" class="headerlink" title="理解 event-loop工作流程"></a>理解 event-loop工作流程</h2><p>来看一个例子：会一次打印出3 2 1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;,<span class="number">100</span>)</span><br><span class="line"><span class="comment">//B</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="常见的一个误区"><a href="#常见的一个误区" class="headerlink" title="常见的一个误区"></a>常见的一个误区</h3><blockquote>
<p>根据开始所说：<strong>如果是同步函数就直接执行，遇到异步函数就放入到异步队列中</strong>。可能会想遇到第一个异步函数时就直接放进去，然后等待主程序执行完就打印1。但实际工作流程如下：</p>
</blockquote>
<p>1.从头开始执行。先明确一个概念，在计算机中，1ms也是很久很久的。<br>2.碰到了异步A，但是有一个100ms的延迟，所以会在100ms后放入异步队列<br>3.碰到了异步B，它没有延迟，所以被直接放入异步队列<br>4.碰到了同步C，所以直接打印 1<br>5.接下来没有函数了，就开始event-loop异步队列，发现里面只有一个异步B，所以被调入到主进程中，直接打印2<br>6.接下来event-loop又到异步队列，但是异步A还在等待<br>7.经过100ms后，异步A终于到了异步队列，此时event-loop发现了它，于是马上将他带入主线程，立刻打印出1 。<strong>需要注意，在这100ms中，event-loop一直在异步队列中检测</strong></p>
<p>以上就是event-loop的一个工作流程。</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>简单的使用promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个简单的promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数Promise在初始化一个实例的时候，有两个参数：resolve、reject</span></span><br><span class="line"><span class="comment">// 并且两个参数都是函数，分工不同。</span></span><br><span class="line"><span class="comment">// resolve表示成功兑现承若，reject表示不能兑现</span></span><br><span class="line"><span class="keyword">const</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="comment">// 直接调用resolve，当然也可以调用reject</span></span><br><span class="line">	resolve(<span class="string">"edison"</span>)</span><br><span class="line">	<span class="comment">// reject("error")</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用promise对象的内置方法then</span></span><br><span class="line"><span class="comment">//then又传入两个callback，一个是当promise中resolve后调用；一个是reject后调用</span></span><br><span class="line">promise.then(<span class="function"><span class="params">lwj</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"edison===lwj"</span>)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Error"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//resolve就输出"edison===lwj"    reject就输出"Error"</span></span><br></pre></td></tr></table></figure>

<h2 id="了解回调函数所带来的问题"><a href="#了解回调函数所带来的问题" class="headerlink" title="了解回调函数所带来的问题"></a>了解回调函数所带来的问题</h2><blockquote>
<p>在了解如何简单使用promise后，肯定会想，为什么需要promise？这就涉及到callback所带来的一些问题</p>
</blockquote>
<p>但是这里步展开讲，了解一下即可。重点是掌握promise</p>
<p>1.错误难以处理<br>2.当有多个callback时，会造成回调地狱<br>3.并行任务棘手</p>
<h2 id="深入研究promise"><a href="#深入研究promise" class="headerlink" title="深入研究promise"></a>深入研究promise</h2><blockquote>
<p>promise对象是用于作为异步任务结果的<strong>占位符</strong>，它代表了一个此刻没有获得但是在未来可能会获得的值。基于此，promise对象的声明周期有不同的状态。</p>
</blockquote>
<blockquote>
<p>一个promise对象从Pending开始，如果调用了resolve，就会进入 ；如果调用了reject，就会进入Rejected</p>
</blockquote>
<h3 id="拒绝promise（捕获异常）"><a href="#拒绝promise（捕获异常）" class="headerlink" title="拒绝promise（捕获异常）"></a>拒绝promise（捕获异常）</h3><p>有两种拒绝方式：</p>
<ol>
<li>显示拒绝，即调用了reject，在此之前我们的then都是传入了两个参数，现在可以将第二个参数去掉，使用.catch()。当reject后就会直接调用.catch()</li>
<li>隐式拒绝，即程序出现错误</li>
</ol>
<h3 id="Promise-all-amp-Promise-race"><a href="#Promise-all-amp-Promise-race" class="headerlink" title="Promise.all &amp; Promise.race"></a>Promise.all &amp; Promise.race</h3><blockquote>
<p>这两函数干嘛的呢？ 别急，看代码</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//看代码能发现，Promise.all传入的是一个promise对象的数组</span></span><br><span class="line"><span class="comment">//然后会返回一个data，也是数组，最后可以打印出来</span></span><br><span class="line"><span class="comment">//简单理解就是需要等所有promise对象执行完才执行then</span></span><br><span class="line"><span class="built_in">Promise</span>.all([promise1,promise2]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data[<span class="number">0</span>])</span><br><span class="line">	<span class="built_in">console</span>.log(data[<span class="number">1</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较发现，传入的参数都是一样的，但是！</span></span><br><span class="line"><span class="comment">//race意味速度，即意思只要有一个promise resolve，那么</span></span><br><span class="line"><span class="comment">//就会返回data</span></span><br><span class="line"><span class="comment">//有点比谁快的意思</span></span><br><span class="line"><span class="comment">//简单理解就是只要有一个promise对象执行完就执行then</span></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1,promise2]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="浅谈async-await"><a href="#浅谈async-await" class="headerlink" title="浅谈async/await"></a>浅谈async/await</h1><blockquote>
<p>async/await是ES7的语法，也是为了解决异步，是终极方案。</p>
</blockquote>
<blockquote>
<p>实际上，promise的then只是对回调函数进行了拆分，避免了回调地狱。</p>
</blockquote>
<p>看一个例子，可以发现这种写法更加简洁，类似于同步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//async表明当前函数依赖于一个异步返回的值</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//在异步函数前，使用await，用来告诉JS引擎</span></span><br><span class="line">	<span class="comment">//在不阻塞应用执行的时候，在这里等待异步执行结果</span></span><br><span class="line">	<span class="keyword">const</span> y=<span class="keyword">await</span> setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">	&#125;,<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">const</span> z=<span class="keyword">await</span> setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">	&#125;,<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结几点：</p>
<ol>
<li>async/await是写异步代码的新方式，以前的方法有回调函数和Promise。</li>
<li>async/await是<strong><u>基于Promise实现</u></strong>的，它不能用于普通的回调函数。</li>
<li>async/await与Promise一样，是非阻塞的。</li>
<li>async/await使得异步代码看起来像同步代码，这正是它的魔力所在。</li>
</ol>
<p>但是要注意，这永远改变不了JS单线程的本质！</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex--getter</title>
    <url>/2020/03/11/vuex--getter/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="what’s-Getter"><a href="#what’s-Getter" class="headerlink" title="what’s Getter ?"></a>what’s Getter ?</h1><blockquote>
<p>假设一个场景，我们需要计算总价，但是state里面只有单品价格和卖出的个数。所以总价为state.price * state.num 。不难发现，总价是依赖state的，并且与它保持响应式的关系。即state变化总价才会变化。这样看是不是有点想computed计算属性？</p>
</blockquote>
<blockquote>
<p>如果这样想也没错，因为getter实际上也可以理解为store的计算属性。要注意，getter的值会被缓存起来</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store=<span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	state:&#123;</span><br><span class="line">		todos:[</span><br><span class="line">			&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">			&#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	getters:&#123;</span><br><span class="line">	<span class="comment">//Getter第一个参数为state</span></span><br><span class="line">		doneTodos:<span class="function"><span class="params">state</span>=&gt;</span>&#123;</span><br><span class="line">		<span class="comment">//filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </span></span><br><span class="line">			<span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span>todo.done)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="通过属性访问"><a href="#通过属性访问" class="headerlink" title="通过属性访问"></a>通过属性访问</h1><blockquote>
<p>Getter会被store.getters暴露。即如果想在组件中使用doneTodos就需要这样写：this.$store.getters.doneTodos</p>
</blockquote>
<blockquote>
<p>上面提到过，getter的一个参数是state，那么第二个参数可以是另外一个getter</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">	doneTodos:<span class="function">(<span class="params">state,getters</span>)=&gt;</span>&#123;</span><br><span class="line">		.....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通过方法访问"><a href="#通过方法访问" class="headerlink" title="通过方法访问"></a>通过方法访问</h1><p>先看一段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">	<span class="comment">//双箭头函数的意思就是调用doneTodos的时候，实际上返回的是一个参数为id的函数</span></span><br><span class="line">	doneTodos:<span class="function"><span class="params">state</span>=&gt;</span><span class="function"><span class="params">id</span>=&gt;</span>&#123;</span><br><span class="line">		....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在组件中调用，好像和属性调用方法没有什么太大的区别，但是要注意看！dongTodos有一个参数，这个参数是用来传递给id的</span></span><br><span class="line"><span class="keyword">this</span>.$store.gettters.doneTodos(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以下是官方文档的描述：你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>
</blockquote>
<h1 id="mapGetters"><a href="#mapGetters" class="headerlink" title="mapGetters"></a>mapGetters</h1><blockquote>
<p>使用方法和mapState差不多</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">	...mapState([<span class="string">"todos"</span>]),</span><br><span class="line">	...mapState(&#123;</span><br><span class="line">		currentTodos:<span class="string">"todos"</span></span><br><span class="line">	&#125;),</span><br><span class="line">	...mapGetters([<span class="string">"doneTodos"</span>]),</span><br><span class="line">	<span class="comment">// 把 `this.currentDone` 映射为 `this.$store.getters.doneTodos`</span></span><br><span class="line">	...mapGetters(&#123;</span><br><span class="line">		currentDone:<span class="string">"doneTodos"</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex--state</title>
    <url>/2020/03/11/vuex--state/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>在了解了基本的概念后，就该深入核心的一些东西了。</p>
</blockquote>
<h1 id="what’s-单一状态树"><a href="#what’s-单一状态树" class="headerlink" title="what’s 单一状态树"></a>what’s 单一状态树</h1><blockquote>
<p>根据文档的描述很懵逼，我发现文档就是把几句话能说懂的非要说的高深，fuck shiiiiiiit</p>
</blockquote>
<blockquote>
<p>首先说说树的数据结构，基本上就和现实生活的树是一样的，一个主干，若干分支，若干树叶。这就是我理解的单一状态树。那么相反呢？假设一棵树有两个树干，那么分支和树叶该依靠谁呢？这就会出现混乱。所以单一状态树就是指整个应用只有一个树干</p>
</blockquote>
<blockquote>
<p>好处？  好处就是不会造成混乱，能够轻而易举的取到某一个树叶，再调试的时候，也能简单的取得当前应用状态的快照</p>
</blockquote>
<h1 id="如何在组件中获取vuex状态呢？"><a href="#如何在组件中获取vuex状态呢？" class="headerlink" title="如何在组件中获取vuex状态呢？"></a>如何在组件中获取vuex状态呢？</h1><blockquote>
<p>通过在根实例中注册store，该store实例会注入到根组件下的所有子组件中，可以通过 this.$store.state去访问state</p>
</blockquote>
<h1 id="mapState辅助函数"><a href="#mapState辅助函数" class="headerlink" title="mapState辅助函数"></a>mapState辅助函数</h1><blockquote>
<p>当一个组件需要从vuex获取多个状态的时候，代码会很冗余。这时候就需要mapState</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line"><span class="comment">// 使用mapState,此时，city已经被映射了，所以可以直接使用this.city去获取属性值</span></span><br><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">//意思是将vuex中的city数据映射到组件的computed属性里</span></span><br><span class="line">    ...mapState([<span class="string">"city"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//还有一种使用方法,意思是将store里面的state里面的city属性映射到computed属性中的currentCity中。即currentCity代表了$store.state.city</span></span><br><span class="line">computed:&#123;</span><br><span class="line">        ...mapState(&#123;</span><br><span class="line">            currentCity:<span class="string">"city"</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex--go</title>
    <url>/2020/03/10/vuex--go/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h2 id="what’s-store-？"><a href="#what’s-store-？" class="headerlink" title="what’s store ？"></a>what’s store ？</h2><blockquote>
<p>每一个vuex的核心就是store。所以什么是store？</p>
</blockquote>
<blockquote>
<p>store说白了就是一个容器，它用来包含应用中绝大多数的state。</p>
</blockquote>
<h3 id="值得注意的两点知识"><a href="#值得注意的两点知识" class="headerlink" title="值得注意的两点知识"></a>值得注意的两点知识</h3><ol>
<li>store与其他全局对象的区别在于，vuex是响应式的。</li>
<li>store不能直接修改state，唯一的途径是通过actions commit 到 mutations（devtools可以查看mutations）</li>
</ol>
<h2 id="store-example"><a href="#store-example" class="headerlink" title="store example"></a>store example</h2><p>以下是最简单的store实例(不使用cli构建)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store=Vuex.Store(&#123;</span><br><span class="line">	<span class="comment">//存放的数据，但是要牢记，不能直接改变它</span></span><br><span class="line">	state:&#123;</span><br><span class="line">		count:<span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">//用来改变state</span></span><br><span class="line">	mutaions:&#123;</span><br><span class="line">		increase(state)&#123;</span><br><span class="line">			count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>接下来就可以获取一些想要的东西</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过commit（详见那张经典图）方法触发状态变更</span></span><br><span class="line">store.commit(<span class="string">"increase"</span>)</span><br><span class="line"><span class="comment">//获取state对象</span></span><br><span class="line">store.state</span><br></pre></td></tr></table></figure>

<h2 id="补充一点"><a href="#补充一点" class="headerlink" title="补充一点"></a>补充一点</h2><p>关于为什么会有actions，因为mutations的操作是同步的，但是js中很多都涉及到异步，所以就有了actions去做异步操作。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>初识vuex</title>
    <url>/2020/03/10/%E5%88%9D%E8%AF%86vuex/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="what’s-Vuex"><a href="#what’s-Vuex" class="headerlink" title="what’s Vuex ?"></a>what’s Vuex ?</h1><blockquote>
<p>Vuex是vue三大核心插件之一。另外两个为Vue Router、Vue SSR。可见其重要性。今天晚上就来攻克它！</p>
</blockquote>
<h2 id="Vuex简介"><a href="#Vuex简介" class="headerlink" title="Vuex简介"></a>Vuex简介</h2><blockquote>
<p>学习它之前，需要先知道为什么需要vuex，什么时候需要vuex。带着这两个疑问先去官方文档一探究竟。</p>
</blockquote>
<h3 id="what’s-状态管理模式"><a href="#what’s-状态管理模式" class="headerlink" title="what’s 状态管理模式"></a>what’s 状态管理模式</h3><blockquote>
<p>首先vuex介绍就是专门为vue开发的状态管理模式。故先来解释一下何为状态管理模式，鄙人所理解的就是好比有很多鸡蛋，是各自放在篮子里还是放在一个篮子好呢？如果鸡蛋只有少数几个可以各自分开放，如果有100个鸡蛋，那么就需要100个篮子。可想而知，剩下就不继续比喻了，很抽象。</p>
</blockquote>
<blockquote>
<p>再来看看文档里的三个关键字：state（驱动view的数据源）、view（以声明的方式（插值表达式）将state映射到视图）、actions（当view发生改变后（用户的操作），所导致的状态变化，然后又去改变state，如此往复循环）</p>
</blockquote>
<blockquote>
<p>对三个关键字理解后，不难发现是一个单向的数据流。问题来了，假设A有一个需求，需要用到某一个数据，刚好这个数据就在B中，但是呢，这个数据需要先经过C处理然后再到A，这样就很繁琐。所以就考虑能不能把数据都提取出来以一个全局单例模式去管理呢？</p>
</blockquote>
<blockquote>
<p>你可能会问，这不是更复杂了？先不想复杂的应用情况，当你使用全局单例模式去管理后，组件需要使用的任何东西都去它哪里取，而不在需要通过别的组件。即一（vuex）对多（view）</p>
</blockquote>
<p>接下来看看官网的一张图，可以发现每一个名词后面都有一个动词去改变它下一个名词。好好体会。</p>
<p><img src="/images/16.png" alt=""></p>
<h2 id="关于vuex应用场景的几点补充"><a href="#关于vuex应用场景的几点补充" class="headerlink" title="关于vuex应用场景的几点补充"></a>关于vuex应用场景的几点补充</h2><p>官网有两句话：</p>
<ol>
<li>多个视图依赖同一个状态</li>
<li>来自不同视图的行为需要改变同一个状态</li>
</ol>
<blockquote>
<p>看完有什么想法？天杀yyx，丫的说啥呢？哈哈哈哈哈哈哈哈哈，以下举两个例子意义对应</p>
</blockquote>
<p>1.比如说用户的登录信息。就跟微博一样，如果你不登陆，在所有页面上你所使用的功能都会受到限制，那么它们是如何知道你是否登录了呢？这就是多个视图需要依赖这个登录状态信息。<br>2.还是登录信息，假设你要退出登录，但是你登录的信息保存在登录页，但是退出需要到退出页面，这就是在另一个视图需要改变同一个登录状态信息。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>环境搭建---美团网</title>
    <url>/2020/03/10/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA---%E7%BE%8E%E5%9B%A2%E7%BD%91/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="会用到的技术"><a href="#会用到的技术" class="headerlink" title="会用到的技术"></a>会用到的技术</h1><blockquote>
<p>vue、node.js、npm、webpack、nuxt.js。安装过程看官方文档。</p>
</blockquote>
<blockquote>
<p>需要安装的软件：mongodb,redis,roto 3t</p>
</blockquote>
<h1 id="会遇到的问题"><a href="#会遇到的问题" class="headerlink" title="会遇到的问题"></a>会遇到的问题</h1><blockquote>
<p>比如说，使用es6的import…from…会报错，不识别import。</p>
</blockquote>
<p>解决办法如下：</p>
<p>首先安装插件，重点是最后一个，因为官网只有前三个，但是没有第四个的话 babel-node是识别不了的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @babel&#x2F;cli @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;node -D</span><br></pre></td></tr></table></figure>

<p>然后在package.json中添加 –exec babel-node –presets @babel/env 。将其添加至dev与start后面即可</p>
<p><strong>注意，以上是在babel 7环境中</strong></p>
]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
  </entry>
  <entry>
    <title>打包上线过程</title>
    <url>/2020/03/10/%E6%89%93%E5%8C%85%E4%B8%8A%E7%BA%BF%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<p>使用@vue/cli自带的ui。打包完成后会在目录下生成一个dist文件夹，然后将dist文件移到服务器根目录即可，如果需要放在根目录下的一个文件夹里，则需要到vue.config.js中去修改assetsPublicPath即可</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>递归组件的使用</title>
    <url>/2020/03/10/%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>假设有这样一个数据,可以发现是一个嵌套的数据关系，在id为0的数据中还包含了二级数据，如果要使用的话就可以使用递归组件。</p>
</blockquote>
<p><img src="/images/14.png" alt=""></p>
<blockquote>
<p>在此之前，我都以为组件的名字只是用来在父组件中使用的，但是还有一个大用处，就是自身去调用自身！牛逼了</p>
</blockquote>
<blockquote>
<p>但是有一点很奇怪，组件使用了DetailList的名子，但是在使用自己使用自己是总是报错该组件未被注册，后来就换了一个组件名，改成了list就成功了，所以以后的组件命名不要使用驼峰形式，简单就好。当然了父组件除外。并且子组件名和父组件中的components名毫无关系。</p>
</blockquote>
<p>递归的具体使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- &#x2F;&#x2F;如果有children这个选项就显示 --&gt;</span><br><span class="line">&lt;div v-if&#x3D;&quot;item.children&quot;&gt;</span><br><span class="line">    &lt;list class&#x3D;&quot;children&quot; :list&#x3D;&quot;item.children&quot;&gt;&lt;&#x2F;list&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/images/15.png" alt=""></p>
<blockquote>
<p>那么三级菜单怎么做呢？直接在二级菜单里面嵌套一个children，其他都不用修改。</p>
</blockquote>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>全局事件的解绑</title>
    <url>/2020/03/10/%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%A7%A3%E7%BB%91/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>如果不进行解绑，那么就会在所有页面生效这个事件。因为他是绑定在window对象上的，所以相当于全局事件</p>
</blockquote>
<p><img src="/images/13.png" alt=""></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vue跳转页面</title>
    <url>/2020/03/10/vue%E8%B7%B3%E8%BD%AC%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>vue有两种方法跳转页面</p>
</blockquote>
<p>使用router-link</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/detail"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">v-for</span>=<span class="string">"item of recommendList"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"item.imgUrl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"info-title"</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"info-desc"</span>&gt;</span>&#123;&#123;item.desc&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>查看详情<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用$router.push 。在需要被触发跳转的元素上绑定跳转事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳转到首页</span></span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">"/"</span>)</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>还有一点需要注意，假设我们要将li标签设置为router-link。此时router-link会将li标签渲染为a标签，显然这不是我们想要的。那么可以这样做。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//tag的意思是告诉router-link不要将此标签渲染为a，而是渲染为li</span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">tag</span>=<span class="string">"li"</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>mapState的使用</title>
    <url>/2020/03/10/mapState%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>如果要获取store里面的state的city属性。首先来看看没有使用mapState的情况,</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;this.$store.state.city&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>再来看看使用mapState后</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123;this.city&#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么为什么会这样呢？先来看看官方的定义：当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：</p>
</blockquote>
<blockquote>
<p>首先什么是状态？即state，state又是用来存储一些数据的，所以不难理解。</p>
</blockquote>
<p>看代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line"><span class="comment">// 使用mapState,此时，city已经被映射了，所以可以直接使用this.city去获取属性值</span></span><br><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">//意思是将vuex中的city数据映射到组件的computed属性里</span></span><br><span class="line">    ...mapState([<span class="string">"city"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>还有一种使用方法,意思是将store里面的state里面的city属性映射到computed属性中的currentCity中。即currentCity代表了$store.state.city</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">        ...mapState(&#123;</span><br><span class="line">            currentCity:<span class="string">"city"</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>数据为对象的v-for的使用</title>
    <url>/2020/03/10/%E6%95%B0%E6%8D%AE%E4%B8%BA%E5%AF%B9%E8%B1%A1%E7%9A%84v-for%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>之前 v-for 都是对数组使用，这次遇到了对象。这有很大的不同。废话不多说，上代码就懂了</p>
</blockquote>
<p>key就是对象的属性名，又因为属性名是不能重复的，所以使用key直接座键值即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul class&#x3D;&quot;list&quot;&gt;</span><br><span class="line">            &lt;li class&#x3D;&quot;item&quot; v-for&#x3D;&quot;(item,key) of cities&quot; :key&#x3D;&quot;key&quot;&gt;&#123;&#123;key&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;CityAlphabet&quot;,</span><br><span class="line">    props:&#123;</span><br><span class="line">        cities:Object</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的使用ref</title>
    <url>/2020/03/10/%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8ref/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>今天使用一个插件 better-scroll 。但是文档里使用方法如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">'better-scroll'</span></span><br><span class="line"><span class="keyword">const</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)</span><br><span class="line"><span class="keyword">const</span> scroll = <span class="keyword">new</span> BScroll(wrapper)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到需要获取这个dom元素，然后还要去使用它。那么问题来了，什么玩意儿可以做到呢？   REF！！！！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取这个DOM元素</span><br><span class="line">&lt;div class&#x3D;&quot;list&quot; ref&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;然后在script中使用</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import BScroll from &quot;better-scroll&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">    name:&quot;CityList&quot;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        this.scroll&#x3D;new BScroll(this.$refs.wrapper)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>配置路由</title>
    <url>/2020/03/10/%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>现在已经写完了第一个大页面，所以得创建第二个。然后有一个需求，就是点击第一个页面的某个地方，然后实现跳转，可以到新创建的页面去。</p>
</blockquote>
<blockquote>
<p>这段代码的重点在  <router-link to="/city"> 意思是点击之后，会被跳转到 “/city” 路径下。 通过查看DOM，实际上这里被转换成为了一个a标签。并且a标签还自带了两个默认属性，其中一个就是color，会将字体颜色改变。所以只需要重置一下字体颜色即可。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/city"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">    &#123;&#123;this.city&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#iconiconzhengli-"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>父子组件之间的传值</title>
    <url>/2020/03/10/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>解决了axios第一座大山，就来到了第二座，可预见的是第三座应该是vuex。废话不多说，直奔主题。</p>
</blockquote>
<blockquote>
<p>首先，假设一个场景。有一个mooc数据文件，然后有一个父组件，父组件有若干个子组件，每一个子组件都需要到mooc提取数据。问题来了，如果让每一个子组件去获取，假设有10个子组件，那么就需要发送10个axios请求，这对性能是不好的。所以现在只让父组件去获取，这样就可以只发一个请求。问题又来了，父组件如何传值给子组件呢？</p>
</blockquote>
<blockquote>
<p>现在有五个子组件，那么父组件就需要在data()里面写五个，分别传值给他们。先不管父组件如何去拿到这些值并且分配给他们。现在只需要关心传值的通道。代码如下，格式为：  :variate=”variate”</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">home-header</span> <span class="attr">:city</span>=<span class="string">"city"</span>&gt;</span><span class="tag">&lt;/<span class="name">home-header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">home-swiper</span> <span class="attr">:swiperList</span>=<span class="string">"swiperList"</span>&gt;</span><span class="tag">&lt;/<span class="name">home-swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">home-icons</span> <span class="attr">:iconsList</span>=<span class="string">"iconsList"</span>&gt;</span><span class="tag">&lt;/<span class="name">home-icons</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">home-recommend</span> <span class="attr">:recommendList</span>=<span class="string">"recommendList"</span>&gt;</span><span class="tag">&lt;/<span class="name">home-recommend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">home-weekend</span> <span class="attr">:weekendList</span>=<span class="string">"weekendList"</span>&gt;</span><span class="tag">&lt;/<span class="name">home-weekend</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题来了，variate从哪儿来？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">        <span class="comment">//要格外注意这里的类型，不能填错</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            city:<span class="string">""</span>,</span><br><span class="line">            swiperList:[],</span><br><span class="line">            iconsList:[],</span><br><span class="line">            recommendList:[],</span><br><span class="line">            weekendList:[],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么要这样写，首先这个父组件是相对的，所以data也需要return。 还有一个关键的地方，就是在写variate的时候，要根据mooc数据的类型来写。但是不能写array、string等</p>
</blockquote>
<blockquote>
<p>说完了传值通道的建立，在来说说子组件是如何使用的。以header为例子，使用props属性从父组件获取city，并且还需要声明类型，并且要写String、Array等，开头要大写</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"HomeHeader"</span>,</span><br><span class="line">    props:&#123;</span><br><span class="line">        city:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后来说说父组件如何获取的值呢？话不多说，到此为止</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将mooc数据里的data赋值给res</span></span><br><span class="line">res=res.data</span><br><span class="line"><span class="comment">//然后判断一下，获取的res是否正确,因为ret为true</span></span><br><span class="line"><span class="keyword">if</span>(res.ret)&#123;</span><br><span class="line">    <span class="keyword">const</span> data=res.data</span><br><span class="line">    <span class="keyword">this</span>.city=data.city</span><br><span class="line">    <span class="keyword">this</span>.swiperList=data.swiperList</span><br><span class="line">    <span class="keyword">this</span>.iconsList=data.iconsList</span><br><span class="line">    <span class="keyword">this</span>.recommendList=data.recommendList</span><br><span class="line">    <span class="keyword">this</span>.weekendList=data.weekendList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>使用axios解决跨域、显示mooc数据（正确版）</title>
    <url>/2020/03/10/%E4%BD%BF%E7%94%A8axios%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E3%80%81%E6%98%BE%E7%A4%BAmooc%E6%95%B0%E6%8D%AE%EF%BC%88%E6%AD%A3%E7%A1%AE%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>天杀的 vue cli 4  。一晚上就弄这个了<del>~</del>。之前的错误版该说的都说了，这次直接贴正确代码。不过有几点要先说。</p>
</blockquote>
<p>1.首先，不懂的一定要先看vue.config.js配置的官网：<a href="https://cli.vuejs.org/zh/config/#devserver-proxy" target="_blank" rel="noopener">https://cli.vuejs.org/zh/config/#devserver-proxy</a><br>2.之前在vue cli 2中，显示mooc和打印mooc都是在vue组件中写的，但是现在是直接在这个配置文件中写。<br>3.还有一些话写在了代码里</p>
<p>vue只看关键部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    getHomeInfo()&#123;</span><br><span class="line">        &#x2F;&#x2F;首先 访问8080， axios去请求这么一个路径  </span><br><span class="line">        &#x2F;&#x2F;接下来，这个路径会到 vue.config.js中</span><br><span class="line">        axios.get(&quot;&#x2F;api&#x2F;index.json&quot;).then(this.getHomeInfoSucc)</span><br><span class="line">    &#125;,</span><br><span class="line">    getHomeInfoSucc(res)&#123;</span><br><span class="line">        &#x2F;&#x2F;这里可以在控制台中打印</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted()&#123;</span><br><span class="line">    this.getHomeInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是重头戏：vue.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> mockdata=<span class="built_in">require</span>(<span class="string">"./mock/index.json"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    lintOnSave: <span class="literal">true</span>,</span><br><span class="line">    chainWebpack: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">        .set(<span class="string">'styles'</span>,resolve(<span class="string">'src/assets/styles'</span>))</span><br><span class="line">        <span class="comment">// 这里只写了两个个，你可以自己再加，按这种格式.set('', resolve(''))</span></span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        <span class="comment">//当Home.vue中的路径过来时，/api/index.json   因为是api开头，</span></span><br><span class="line">        <span class="comment">//所以这个路径被跨域到 http://localhost:8080/mock/index.json </span></span><br><span class="line">        <span class="comment">//即实际上访问8080时，访问的是http://localhost:8080/mock/index.json</span></span><br><span class="line">        <span class="comment">//这样就拿到了mooc的数据。</span></span><br><span class="line">        <span class="comment">//拿到之后，就回到vue开始执行then。   </span></span><br><span class="line">        <span class="comment">//到此结束！！！！</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/api'</span>: &#123;</span><br><span class="line">                target: <span class="string">'http://localhost:8080'</span>,</span><br><span class="line">                pathRewrite:&#123;</span><br><span class="line">                    <span class="string">'^/api'</span>:<span class="string">'/mock'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'/foo'</span>: &#123;</span><br><span class="line">            target: <span class="string">'http://localhost:8080'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//用来显示假数据，即如果直接访问 http://localhost:8080/api/index.json</span></span><br><span class="line">        <span class="comment">//就会在页面打印mock数据</span></span><br><span class="line">        port:<span class="number">8080</span>,</span><br><span class="line">        before(app)&#123;</span><br><span class="line">            app.get(<span class="string">'/api/index.json'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">                res.json(mockdata)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>使用axios跨域（错误！！！）</title>
    <url>/2020/03/10/%E4%BD%BF%E7%94%A8axios%E8%B7%A8%E5%9F%9F%EF%BC%88%E9%94%99%E8%AF%AF%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%89/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>由于教程用的 vue-cli 2，但是现在使用 4 版本了。已经不能按着教程搞了。当然了，实际上教程对我也只是学习一下css布局和基础的东西，虽然css写的很烂</p>
</blockquote>
<blockquote>
<p>接下来就来看一下，在@vue/cli中如何处理跨域</p>
</blockquote>
<p>先看远古时期的版本： webpack</p>
<p><img src="/images/11.png" alt="从proxyTable开始"></p>
<p>接下来就是现在的，弄了接近一个钟，操！</p>
<p>当然了，还得引入mock</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mockdata=<span class="built_in">require</span>(<span class="string">"./mock/index.json"</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/12.png" alt="从devServer开始"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在一个组件中修改另一个组件的样式</title>
    <url>/2020/03/10/%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>其实可以直接修改，但是现在vue的style都会加上scoped，是为了防止样式污染。这样也就带来了其他的不便，比如今天要解决的这个问题。</p>
</blockquote>
<p>使用穿透符号 &gt;&gt;&gt;。表示让 .wrapper 下面的所有 .swiper-pagination-bullet-active 都加上样式。<br>这样就可以不受scoped的限制</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &gt;&gt;&gt; .swiper-pagination-bullet-active</span><br><span class="line">    <span class="attribute">background</span>:white</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中修改别名（alias）</title>
    <url>/2020/03/10/vue%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%88%AB%E5%90%8D%EF%BC%88alias%EF%BC%89/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>这里踩了很大的坑，记录下来。</p>
</blockquote>
<blockquote>
<p>因为使用的是最新的脚手架工具 @vue/cli ，它不会生成任何webpack文件，所以需要手动创建。  根据官方文档 ：需要创建vue.config.js</p>
</blockquote>
<blockquote>
<p>还有一个坑，就是没有安装 path ，导致无法解析路径</p>
</blockquote>
<p>下面上代码就懂了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">function resolve(dir) &#123;</span><br><span class="line">    return path.join(__dirname, dir);</span><br><span class="line">    &#125;</span><br><span class="line">    module.exports &#x3D; &#123;</span><br><span class="line">    lintOnSave: true,</span><br><span class="line">    chainWebpack: (config) &#x3D;&gt; &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">        .set(&#39;styles&#39;,resolve(&#39;src&#x2F;assets&#x2F;styles&#39;))</span><br><span class="line">        &#x2F;&#x2F; 这里只写了两个个，你可以自己再加，按这种格式.set(&#39;&#39;, resolve(&#39;&#39;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中css代码优化----样式篇</title>
    <url>/2020/03/10/vue%E4%B8%ADcss%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96----%E6%A0%B7%E5%BC%8F%E7%AF%87/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>在写css的时候有时候会大量重复使用一些颜色，加入今后要修改，就得修改所有的地方，这样显然不符合分离的设计（解耦）。所以应该怎么做呢？</p>
</blockquote>
<p>1.创建一个新文件，里面存放样式</p>
<p>varibles.stylus：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="variable">$bgColor</span>=<span class="number">#00bcd4</span></span><br></pre></td></tr></table></figure>

<p>2.在style中引用</p>
<p>这里一定要注意，@是webpack定义的src目录。但是这里在使用是需要加~    即~@</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"文件所在的相对路径/varibles.stylus"</span></span><br><span class="line">或者使用~@代替路径</span><br><span class="line">@import <span class="string">"~@/assets/styles/varibles.stylus"</span></span><br></pre></td></tr></table></figure>

<p>3.使用</p>
<p>最后将 #00bcd4 替换成 $bgColor</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 @vue/cli 初始化一个Vue项目</title>
    <url>/2020/03/10/%E4%BD%BF%E7%94%A8-@vuecli-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<p>现在一起来学习如何初始化一个Vue项目</p>
<p>1.现在一般都会同步到github。所以首先在github新建一个仓库<br>2.然后将线上的仓库clone至本地。最好选择ssh<br>3.进给希望保存代码的路径，然后git bash here。<br>4.执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &quot;复制的ssh地址&quot;</span><br></pre></td></tr></table></figure>
<p>5.安装脚手架工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">cnpm install -g @vue&#x2F;cli</span><br></pre></td></tr></table></figure>
<p>6.现在的脚手架已经比vue-cli要高级多了，推荐使用vue ui命令打开可视化矿口进行创建项目并且管理<br>7.大功告成~</p>
<hr>
<p>在对比vue-cli将近半小时，才把整个项目真正弄完，下面贴上修改后的文件树：</p>
<ol>
<li>assets ：存放静态文件，如iconfont、css、js等</li>
<li>components：这里忘记看不到里面的home文件夹，实际上header组件存放在home中。这样做的目的是可以最大限度将组件也抽离出来</li>
<li>router：和components一一对应。里面的index.js是将整个router的大组件全都配置好。</li>
<li>store：现在用不到，根据里面初始化的代码来看，是有关vuex的。以后在深入学习</li>
<li>至此 大功告成！</li>
</ol>
<p><img src="/images/10.png" alt="需要体会解耦才能懂"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>computed VS watch</title>
    <url>/2020/03/10/computed-VS-watch/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h4 id="computed是计算属性，什么意思呢？"><a href="#computed是计算属性，什么意思呢？" class="headerlink" title="computed是计算属性，什么意思呢？"></a>computed是计算属性，什么意思呢？</h4><blockquote>
<p>就好比通过两个值计算出来第三个值，并且这第三个值不需要提前声明。不理解？等下上代码就懂了</p>
</blockquote>
<h4 id="watch是侦听属性，什么意思呢"><a href="#watch是侦听属性，什么意思呢" class="headerlink" title="watch是侦听属性，什么意思呢?"></a>watch是侦听属性，什么意思呢?</h4><blockquote>
<p>还是跟上面一样，现在需要计算第三个值，但是呢，它需要先提前声明，然后让它去等于另外两个值的结果。不理解？等下上代码就懂了</p>
</blockquote>
<p><img src="/images/9.png" alt="好好体会"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>props遇到的一些问题</title>
    <url>/2020/03/10/props%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<p>今天重学vue基础时，突发奇想在props上使用了自己瞎定义的一个单词，刚好就有一个大写字母：itemAtr==&gt;itemAttribute</p>
<p>然后呢就一直报错：提示无法读取data中定义的数据。后来将A改写为a就正常了！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'todoItem'</span>, &#123;</span><br><span class="line">    props: [<span class="string">'itematr'</span>],</span><br><span class="line">    template: <span class="string">'&lt;li&gt;&#123;&#123; itematr.text &#125;&#125;&lt;/li&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        items: [</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">'蔬菜'</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'奶酪'</span> &#125;,</span><br><span class="line">            &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'随便其它什么人吃的东西'</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>贴近企业级开发的git使用</title>
    <url>/2020/03/09/git%E5%9C%A8%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>一般来说，每开发一个新功能，都会拉取一个新的分支。当完成分支后，会将分支合并到master上。废话不多说，直接看代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个分支</span><br><span class="line">git branch swiper</span><br><span class="line">&#x2F;&#x2F; 查看所有分支</span><br><span class="line">git branch</span><br><span class="line">&#x2F;&#x2F; 将创建的分支推送到github</span><br><span class="line">git push origin swiper</span><br><span class="line">&#x2F;&#x2F; 切换当前分支</span><br><span class="line">git checkout swiper</span><br><span class="line">&#x2F;&#x2F; 查看当前分支 （作用不知用来查看当前分支~）</span><br><span class="line">git status</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当一个功能(swiper)开发完成之后</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;提交</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;xxxx&quot;</span><br><span class="line">git push origin swiper</span><br><span class="line">&#x2F;&#x2F; 先切换到主分支</span><br><span class="line">git checkout master</span><br><span class="line">&#x2F;&#x2F; 合并</span><br><span class="line">git merge origin&#x2F;swiper</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>vue-awesome-swiper</title>
    <url>/2020/03/09/vue-awesome-swiper/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>今天做vue的轮播功能，然后遇到了很大的坑，首先是最新版的插件是基于swiper4.相比swiper5及其难用。导致弄了很久才排除大坑</p>
</blockquote>
<p>最值得一提的是，在手动去化轮播图时，会报错：</p>
<p><img src="/images/7.png" alt=""></p>
<p>最后在网上找到一个解决方案：去swiper的js文件中搜索 e.preventDefault() 然后将其屏蔽即可。</p>
<blockquote>
<p>接下来说说在vue中如何使用。当然，具体的参考swiper4官方文档！</p>
</blockquote>
<p><img src="/images/8.png" alt="因为不止一个组件使用到iswiper，所以定义到全局"></p>
<p>在组件中就直接粘贴代码了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The ref attr used to find the swiper instance --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span> <span class="attr">ref</span>=<span class="string">"mySwiper"</span> @<span class="attr">someSwiperEvent</span>=<span class="string">"callback"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- slides --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>I'm Slide 1<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>I'm Slide 2<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>I'm Slide 3<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>I'm Slide 4<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>I'm Slide 5<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>I'm Slide 6<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>I'm Slide 7<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Optional controls --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>  <span class="attr">slot</span>=<span class="string">"pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-button-prev"</span> <span class="attr">slot</span>=<span class="string">"button-prev"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-button-next"</span> <span class="attr">slot</span>=<span class="string">"button-next"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-scrollbar"</span>   <span class="attr">slot</span>=<span class="string">"scrollbar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name: <span class="string">'carrousel'</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        swiperOption: &#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">// some swiper options/callbacks</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 所有的参数同 swiper 官方 api 参数</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// ...</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      swiper() &#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="keyword">this</span>.$refs.mySwiper.swiper</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// current swiper instance</span></span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 然后你就可以使用当前上下文内的swiper对象去做你想做的事了</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'this is current swiper instance object'</span>, <span class="keyword">this</span>.swiper)</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.swiper.slideTo(<span class="number">3</span>, <span class="number">1000</span>, <span class="literal">false</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>插件</category>
      </categories>
  </entry>
  <entry>
    <title>炫酷的文字渐变效果</title>
    <url>/2020/03/09/%E7%82%AB%E9%85%B7%E7%9A%84%E6%96%87%E5%AD%97%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">margin-left .2rem</span><br><span class="line">font-size .28rem</span><br><span class="line"><span class="attribute">background-image</span>: </span><br><span class="line">-webkit-gradient( linear, <span class="attribute">left</span> top, right top, color-stop(<span class="number">0</span>, <span class="number">#f22</span>), </span><br><span class="line"><span class="function"><span class="title">color-stop</span><span class="params">(<span class="number">0.15</span>, <span class="number">#f2f</span>)</span></span>, </span><br><span class="line"><span class="function"><span class="title">color-stop</span><span class="params">(<span class="number">0.3</span>, <span class="number">#22f</span>)</span></span>, </span><br><span class="line"><span class="function"><span class="title">color-stop</span><span class="params">(<span class="number">0.45</span>, <span class="number">#2ff</span>)</span></span>, </span><br><span class="line"><span class="function"><span class="title">color-stop</span><span class="params">(<span class="number">0.6</span>, <span class="number">#2f2</span>)</span></span>,</span><br><span class="line"><span class="function"><span class="title">color-stop</span><span class="params">(<span class="number">0.75</span>, <span class="number">#2f2</span>)</span></span>, </span><br><span class="line"><span class="function"><span class="title">color-stop</span><span class="params">(<span class="number">0.9</span>, <span class="number">#ff2</span>)</span></span>, </span><br><span class="line">color-stop(1, #f22) );</span><br><span class="line"><span class="attribute">color</span> transparent</span><br><span class="line">-webkit-<span class="attribute">background-clip</span> text</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<p><img src="/images/6.png" alt=""></p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>溢出问题</title>
    <url>/2020/03/09/%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>有一个现象，就是一个页面东西太多放不下就会自动出现一个滚轮，由于是默认的，不太行，所以需要对css做一点改变</p>
</blockquote>
<p>先上两张图</p>
<p><img src="/images/4.png" alt="未设置样式"></p>
<p><img src="/images/5.png" alt="设置样式后"></p>
<blockquote>
<p>能发现是怎么做的吗？首先定位为绝对定位，此时，是相对除了城市选择和搜索框的其他部分。</p>
</blockquote>
<blockquote>
<p>为了能让整个页面都被选择并且表现为红色，css如下</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.list</span><br><span class="line">        <span class="attribute">position</span> absolute</span><br><span class="line">        <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">right</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">bottom</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">background-color</span> red</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是此时依然可以滚动，似乎没有达到预期的效果。接着看代码</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.list</span><br><span class="line">        <span class="attribute">overflow</span> hidden</span><br><span class="line">        <span class="attribute">position</span> absolute</span><br><span class="line">        <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">right</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">top</span> <span class="number">1.58rem</span></span><br><span class="line">        <span class="attribute">bottom</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">background-color</span> red</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，在修改了样式之后，有一个关键的地方就是overflow hidden。 他才可以让整个页面不在滑动。</p>
</blockquote>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>完美解决iconfont svg格式的定位问题</title>
    <url>/2020/03/09/%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3iconfont%20svg%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>因为使用svg格式有很多好处，虽然我只缠它的身体哈哈哈哈。但是相比较于iconfont的传统格式，首先它不是文本，所以不能直接使用text-align，因为要大量的使用居中对齐，所以显然使用svg对于之前的我是个灾难。</p>
</blockquote>
<blockquote>
<p>刚刚都做到第二个页面了，第一个页面的svg我并没有对齐哈哈哈，刚刚自己琢磨了很久，试着在外面包裹了div，才让它动一下。</p>
</blockquote>
<blockquote>
<p>可是还有一个致命的问题，就是在放大svg的时候，他不会随着中心的放大，而是在其上方有一个中心点。这就难办了~</p>
</blockquote>
<blockquote>
<p>可是能难倒我吗？显然不可能。打开f12，发现丫的svg居然一个图标其实又好几部分组成，然后找到它最大的一部分，发现是svg.icon。所以可以开始写样式了。核心就是把svg当成一个块级元素去定位。好好理解~</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">        城市选择</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"iconBox"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">svg</span> <span class="attr">class</span>=<span class="string">"icon"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">"#iconfanhui1"</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    name:<span class="string">"CityHeader"</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">"stylus"</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@import</span> <span class="string">"~styles/varibles.stylus"</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.header</span></span></span><br><span class="line">        position relative</span><br><span class="line"><span class="css">        <span class="selector-tag">height</span> 0<span class="selector-class">.86rem</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">line-height</span> <span class="selector-class">.86rem</span></span></span><br><span class="line">        overflow hidden</span><br><span class="line">        text-align center</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span> <span class="selector-id">#fff</span></span></span><br><span class="line">        background $bgColor</span><br><span class="line"><span class="css">        <span class="selector-tag">font-size</span> <span class="selector-class">.32rem</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.iconBox</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span> <span class="selector-class">.86rem</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span> <span class="selector-class">.86rem</span></span></span><br><span class="line">            display inline</span><br><span class="line">            position absolute</span><br><span class="line">            top 0</span><br><span class="line">            left 0</span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span> 0 0 0 <span class="selector-class">.3rem</span></span></span><br><span class="line"><span class="css">            <span class="selector-class">.icon</span> </span></span><br><span class="line">                position absolute</span><br><span class="line">                top 0</span><br><span class="line">                left 0</span><br><span class="line">                bottom 0</span><br><span class="line">                right 0</span><br><span class="line">                margin auto 0</span><br><span class="line"><span class="css">                <span class="selector-tag">width</span> <span class="selector-class">.4rem</span></span></span><br><span class="line"><span class="css">                <span class="selector-tag">height</span> <span class="selector-class">.4rem</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>关于stylus的方法解耦</title>
    <url>/2020/03/09/%E5%85%B3%E4%BA%8Estylus%E7%9A%84%E6%96%B9%E6%B3%95%E8%A7%A3%E8%80%A6/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>废话不多说直接上图</p>
</blockquote>
<p>将文字过长后添加省略号的方法抽离、并且使用</p>
<p>mixins.stylus (方法)</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ellipsis</span><span class="params">()</span></span></span><br><span class="line">    <span class="attribute">overflow</span> hidden</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap</span><br><span class="line">    <span class="attribute">text-overflow</span> ellipsis</span><br></pre></td></tr></table></figure>

<p>在vue组件中使用，这里可能会出现不生效的问题，只需要在父元素中添加 ：min-width 0  即可</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入文件</span></span><br><span class="line">@import <span class="string">"~styles/mixins.stylus"</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">.info-desc</span><br><span class="line">      margin-top .2rem</span><br><span class="line">      ellipsis()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>当图片宽高和轮播图的框不一致时</title>
    <url>/2020/03/09/%E5%BD%93%E5%9B%BE%E7%89%87%E5%AE%BD%E9%AB%98%E5%92%8C%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E6%A1%86%E4%B8%8D%E4%B8%80%E8%87%B4%E6%97%B6/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>在使用swiper时，遇到了插入的图片宽高和想在页面上展示的宽高不一致的问题，这样就很头疼，并且还要考虑网络差时页面抖动的问题。因为是图片，加入下面是文字，就会加载的比轮播快，那么很可能文字就会先显示在轮播的位置，等轮播加载完后在被挤下来.</p>
</blockquote>
<p>废话不多说，直接上代码</p>
<p>img（333*222）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://z1.muscache.cn/im/pictures/8e737c5e-4fd8-4ad7-92b2-490a8e46c4ec.jpg?aki_policy=large"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://z1.muscache.cn/im/pictures/bcb57d96-a776-4084-a69e-37a5c2ed6762.jpg?aki_policy=large"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://z1.muscache.cn/im/pictures/c3ee793c-eeec-4a75-99ef-80984fedcfda.jpg?aki_policy=large"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>  <span class="attr">slot</span>=<span class="string">"pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>重点是padding-bottom 66.67% 是相对与.wrapper的宽度的百分比，<br>这样就能实现宽高自适应</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.wrapper</span><br><span class="line">        <span class="attribute">overflow</span> hidden</span><br><span class="line">        <span class="attribute">padding-bottom</span> <span class="number">66.67%</span>   </span><br><span class="line">        <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">        <span class="attribute">height</span> <span class="number">0</span></span><br><span class="line">        img</span><br><span class="line">            <span class="attribute">width</span> <span class="number">100%</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>金山办公2020校招前端开发工程师笔试题</title>
    <url>/2020/03/09/%E9%87%91%E5%B1%B1%E5%8A%9E%E5%85%AC2020%E6%A0%A1%E6%8B%9B%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>每天看看面试题，巩固知识，冲鸭</p>
</blockquote>
<hr>
<h1 id="一-、写出如下代码的执行结果"><a href="#一-、写出如下代码的执行结果" class="headerlink" title="一 、写出如下代码的执行结果"></a>一 、写出如下代码的执行结果</h1><blockquote>
<p>考察了 promise，以及任务处理顺序。promise值得单写一篇文章，这里不过多赘述。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'1'</span>)</span><br><span class="line">	resolve()</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'2'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>首先需要搞清楚JS中是单线程的，并且执行的优先级是同步大于异步，并且是所有同步执行完后才回来执行异步操作</li>
<li>异步操作中又分为微任务（promise等）和宏任务（setTimeOut、I/O操作等）。顾名思义，微任务是具体的点，而宏任务是大的一个块儿。</li>
<li>微任务和宏任务的执行顺序为前者优先</li>
</ol>
<blockquote>
<p>所以，正确答案：1 2 5 3 4</p>
</blockquote>
<h1 id="二-、请列举几种除了px外的CSS度量单位并解释其含义。"><a href="#二-、请列举几种除了px外的CSS度量单位并解释其含义。" class="headerlink" title="二 、请列举几种除了px外的CSS度量单位并解释其含义。"></a>二 、请列举几种除了px外的CSS度量单位并解释其含义。</h1><ol>
<li>rem 相对于根字体大小的单位，比如可以设置 1rem=50px</li>
<li>em 相对于font-size，比如font-size：16px（浏览器默认），则2em=32px</li>
<li>vm 即viewpoint width，视窗宽度，比如1vm的宽度为相对于视窗的宽度的百分之一</li>
<li>vh 即viewpoint height ，同上</li>
</ol>
<h1 id="三-、new操作符做了什么？"><a href="#三-、new操作符做了什么？" class="headerlink" title="三 、new操作符做了什么？"></a>三 、new操作符做了什么？</h1><blockquote>
<p>考察原型和原型链，这个知识不在赘述</p>
</blockquote>
<p>简单点来说，new操作符会先创建一个空对象，然后将this指向这个空对象，并且进行赋值，最后返回这个this。<br>但是其中还涉及到了<strong>proto</strong> 、prototype,不过多赘述</p>
<h1 id="四-、简述cookie-session记住登录状态机制原理。"><a href="#四-、简述cookie-session记住登录状态机制原理。" class="headerlink" title="四 、简述cookie/session记住登录状态机制原理。"></a>四 、简述cookie/session记住登录状态机制原理。</h1><blockquote>
<p>这里不写答案，但是要知道cookie和session的作用。同时还要了解一下token。</p>
</blockquote>
<h1 id="五-、网页中接收事件的顺序（事件流）有哪些？它们之间的区别是什么？"><a href="#五-、网页中接收事件的顺序（事件流）有哪些？它们之间的区别是什么？" class="headerlink" title="五 、网页中接收事件的顺序（事件流）有哪些？它们之间的区别是什么？"></a>五 、网页中接收事件的顺序（事件流）有哪些？它们之间的区别是什么？</h1><p>首先说一下什么是事件流，个人理解为假设在牛客网做题，当我点击了提交按钮，浏览器是如何知道我点击了什么东西呢？这个时候就需要使用到事件流</p>
<p>最开始有两种，一个是冒泡，一个是事件捕获。</p>
<p>先说说冒泡：和冒泡排序一样（虽然这是个憨批算法），都是从最底层开始，即那个点击按钮的标签</p>
<p>假设这是个DOM,那么冒泡流就是从p开始，到div，然后body、html、document</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    body</span><br><span class="line">      div</span><br><span class="line">        p 提交</span><br></pre></td></tr></table></figure>

<p>再来说说事件捕获流：不用说太多，因为这刚好和上面是冒泡流相反，即从最外层的标签开始，最后才到达p标签。</p>
<p>最后来说说现在标准，DOM2级事件流，即首先进行事件捕获流，然后到达事件所在的标签后，进行处理，然后在开始进行事件冒泡流，类似于koa2中的洋葱模型</p>
<h1 id="六-、简述你对HTTP控制访问（CORS）的理解"><a href="#六-、简述你对HTTP控制访问（CORS）的理解" class="headerlink" title="六 、简述你对HTTP控制访问（CORS）的理解"></a>六 、简述你对HTTP控制访问（CORS）的理解</h1><p>首先要搞明白什么是同源，什么是跨域。</p>
<p>打一个简单的比方，你自己从你家里拿东西，不会有人说，这是同源；但是你要从隔壁的邻居的冰箱去拿可乐，你觉得可能吗，这就是跨域。</p>
<p>从比方中回来，事实其实没有那么简单。理解了概念后，得知道如何去判断同源还是跨域。web服务器有三要素：协议（http、https）、端口号（不过多说）、web服务器域名（比如<a href="https://github.com/mamba666" target="_blank" rel="noopener">https://github.com/mamba666</a><br>中<a href="https://github.com就是域名）。三要素必须全部一致才算同源" target="_blank" rel="noopener">https://github.com就是域名）。三要素必须全部一致才算同源</a></p>
<p>个人认为写完上面的东东后已经理解了同源跨域已经如何区分。接下来就来看看真正的干货，不讲同源，只讲跨域（以下参考MDN）</p>
<h3 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h3><p>如果发现有一个请求是跨域，那么浏览器会自动先拦截一下，给它的http header加上Origin字段。比如 <a href="http://localhost:8080变为Origin:http://localhost:8080。这样一来，服务器端就可以区分这个请求是不是跨域了。">http://localhost:8080变为Origin:http://localhost:8080。这样一来，服务器端就可以区分这个请求是不是跨域了。</a></p>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>当服务器端收到浏览器端发送过来的请求后，会有一个响应header。它会告诉请求的浏览器哪儿些域名可以请求我，哪儿些方法可以执行。</p>
<h3 id="响应回到浏览器端"><a href="#响应回到浏览器端" class="headerlink" title="响应回到浏览器端"></a>响应回到浏览器端</h3><p>此时浏览器会根据这个响应自动判断，然后在做决定。</p>
<h3 id="服务器端返回给浏览器端的东西"><a href="#服务器端返回给浏览器端的东西" class="headerlink" title="服务器端返回给浏览器端的东西"></a>服务器端返回给浏览器端的东西</h3><ul>
<li>Access-Control-Allow-Origin  允许跨域的Origin列表</li>
<li>Access-Control-Allow-Methods  允许跨域的方法列表（GET、POST等）</li>
<li>Access-Control-Allow-Headers  允许跨域的Header列表</li>
<li>Access-Control-Expose-Headers  允许暴露给JavaScript代码的Header列表</li>
<li>Access-Control-Max-Age  最大的浏览器缓存时间，单位为s</li>
</ul>
<h3 id="跨域请求形式"><a href="#跨域请求形式" class="headerlink" title="跨域请求形式"></a>跨域请求形式</h3><p>有两种，简单和非简单请求。这里说说我常遇到的 application/json 。这就是一种非简单请求，在以上所写的浏览器端之前，会先进行一次预请求，根据这个结果再去判断是否正式请求。</p>
<blockquote>
<p>其实写了这么多，最重要的就是对CORS的理解，已经这个流程是怎么样的。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>三七互娱前端面试</title>
    <url>/2020/03/09/%E4%B8%89%E4%B8%83%E4%BA%92%E5%A8%B1%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>明天下午就要参加三七互娱的前端笔试了，但是心里没底，没有做过题，所以今天恶补一下。一下题目均为三七互娱前端题</p>
</blockquote>
<hr>
<h1 id="一、用js写出一个冒泡排序算法。"><a href="#一、用js写出一个冒泡排序算法。" class="headerlink" title="一、用js写出一个冒泡排序算法。"></a>一、用js写出一个冒泡排序算法。</h1><blockquote>
<ol>
<li>看到这个题我是懵的，因为冒泡排序我已经忘了具体是啥了。</li>
<li>知识点：冒泡排序算法</li>
</ol>
</blockquote>
<p>首先解释一下冒泡排序算法：好比有一个水缸，现在有 N 个水泡在里面，并且杂乱无章的竖直排列。然后因为自然规律，水泡大的会先浮出来。所以算法来了，就是从水缸底部开始依次比较，如果最底部的大于它上面的那个，就往上浮动，然后小的那个就被挤下去。如此，就两两比较，直到最大的到最上面，第一轮结束。第二轮，又从最底部开始，与上相同，直到重复了 N-1 次。</p>
<p>其实跟以前学C语言做那种有形状的字母排序是一个道理。核心就是有一个空的地方可以存放大的，然后换位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bubbleSort=<span class="function"><span class="params">array</span>=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> len=array.length</span><br><span class="line">	<span class="keyword">let</span> temp</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;len<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                  temp=array[j];</span><br><span class="line">                  array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                  array[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(array)) <span class="comment">//1234568</span></span><br></pre></td></tr></table></figure>

<h1 id="二-、CSS中的选择器的优先级是怎么样的？如何优化选择器？"><a href="#二-、CSS中的选择器的优先级是怎么样的？如何优化选择器？" class="headerlink" title="二 、CSS中的选择器的优先级是怎么样的？如何优化选择器？"></a>二 、CSS中的选择器的优先级是怎么样的？如何优化选择器？</h1><p>优先级：行内样式&gt;id&gt;class&gt;标签</p>
<p>优化：</p>
<ol>
<li>避免使用通配符，因为css属性是可以继承的，如果说在通配符中设置了颜色，那么有时候想让某个字颜色是继承的父级元素，那么这时不会生效，而是通配符所设置的颜色。所以通配符的使用要慎重。</li>
<li>尽量少操作标签，而是使用class。</li>
<li>通过继承去少写一些重复的代码。</li>
<li>尽量少使用后代选择器，因为后代选择器不仅选择子代，还会选择孙子。。。。。哈哈哈。意思就是选择的太多了！但是，还是要分情况，因为只使用子代选择器可能会造成代码量过多，所以要灵活使用</li>
</ol>
<h1 id="三-、使用HTML5写出一个页面，包含头部、页头、页脚、文字内容和图片"><a href="#三-、使用HTML5写出一个页面，包含头部、页头、页脚、文字内容和图片" class="headerlink" title="三 、使用HTML5写出一个页面，包含头部、页头、页脚、文字内容和图片"></a>三 、使用HTML5写出一个页面，包含头部、页头、页脚、文字内容和图片</h1><blockquote>
<p>考察的是h5的语义化标签，常用的有header、footer、nav（导航栏标签，定义导航栏）、section、video、audio、article（独立的内容区域，文本类型）、aside（页面的侧边栏去使用）、details（展示详情，使用场景比如说点击展开详情）、mark（会给一个字段添加背景色，并且不能被修改）、progress（进度条，但是丑）、section（类似于平时用div去包裹一个组件使用）、datalist（模糊查询）、canvas（大名鼎鼎的画布，还没学习哈哈哈）、dialog（聊天框）等等</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下省略标签符号--&gt;</span></span><br><span class="line">        hgroup</span><br><span class="line">        p</span><br><span class="line">        dialog</span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="四-、前端页面的优化方法有哪些？有什么优化工具？"><a href="#四-、前端页面的优化方法有哪些？有什么优化工具？" class="headerlink" title="四 、前端页面的优化方法有哪些？有什么优化工具？"></a>四 、前端页面的优化方法有哪些？有什么优化工具？</h1><p>优化方法：</p>
<ol>
<li>减少http请求，特别是vue在请求http时，要将请求放在父组件中，不然每个子组件都去请求一遍就很浪费性能</li>
<li>CSS写在顶部，JavaScript写在尾部或异步</li>
<li>延时加载图片</li>
<li>使用iconfont</li>
<li>使用CDN</li>
<li>使用缓存，在vue中可以使用keep-alive，这样重复访问一个页面时就不会重新去请求，而是从缓存中取出来直接使用。</li>
</ol>
<p>优化工具：</p>
<ol>
<li>真实用户浏览页面分析：OneAPM Browser Insight（统计分析网站流量，定位网站性能瓶颈）</li>
<li>页面结构分析工具： PageSpeed（google官方的页面载入速度检测工具）</li>
</ol>
<h1 id="五-、创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄"><a href="#五-、创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄" class="headerlink" title="五 、创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄"></a>五 、创建子类Child，使用原型和构造函数的方式继承父类People的方法，并调用say函数说出姓名和年龄</h1><blockquote>
<p>考察原型和原型链,JS三座大山自不必说</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name=<span class="string">"edison"</span></span><br><span class="line">	<span class="keyword">this</span>.age=<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params">age,name</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"my name is "</span>+name+<span class="string">" and i am "</span>+age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child=<span class="keyword">new</span> People()</span><br><span class="line">child.say(<span class="number">23</span>,<span class="string">"bruce"</span>) <span class="comment">//my name is bruce and i am 23</span></span><br><span class="line">child.__proto__.say(<span class="number">23</span>,<span class="string">"bruce"</span>) <span class="comment">//和上面效果一样，不过时调用了__proto__</span></span><br></pre></td></tr></table></figure>

<h1 id="六、2016-12-12类型的日期格式校验正则表达式"><a href="#六、2016-12-12类型的日期格式校验正则表达式" class="headerlink" title="六、2016-12-12类型的日期格式校验正则表达式"></a>六、2016-12-12类型的日期格式校验正则表达式</h1><blockquote>
<p>考察正则，这是短板没学过，恶补一下</p>
</blockquote>
<h1 id="七-、使用ajax（可使用jQuery框架，若使用其他框架请注明）写一个跨域异步获取JSON数据方案；说说能否使用JS进行跨域异步post数据"><a href="#七-、使用ajax（可使用jQuery框架，若使用其他框架请注明）写一个跨域异步获取JSON数据方案；说说能否使用JS进行跨域异步post数据" class="headerlink" title="七 、使用ajax（可使用jQuery框架，若使用其他框架请注明）写一个跨域异步获取JSON数据方案；说说能否使用JS进行跨域异步post数据"></a>七 、使用ajax（可使用jQuery框架，若使用其他框架请注明）写一个跨域异步获取JSON数据方案；说说能否使用JS进行跨域异步post数据</h1><p>使用post参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用vue</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;这是在页面中请求axios，即ajax</span><br><span class="line">axios.get(&quot;api&#x2F;index.json&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这是在webpack配置跨域</span><br><span class="line">proxy:&#123;</span><br><span class="line">	&#x2F;&#x2F;一旦遇到api开头的就直接转到target对应的网址</span><br><span class="line">	&quot;&#x2F;api&quot;:&#123;</span><br><span class="line">		target:&quot;http:&#x2F;&#x2F;localhost:8080&quot;,</span><br><span class="line">		&#x2F;&#x2F;使用正则，意思是一旦遇到api，就替换为mooc</span><br><span class="line">		pathRewrite:&#123;</span><br><span class="line">			&quot;^&#x2F;api&quot;:&quot;&#x2F;mook&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八-、考察样式"><a href="#八-、考察样式" class="headerlink" title="八 、考察样式"></a>八 、考察样式</h1><blockquote>
<p>常见的背景颜色、文字居中、边框、文字阴影、模糊等</p>
</blockquote>
<h1 id="九-、对数组testArray进行以下操作：a-从前面删除一个数字-b-从前面增加一个数字5-c-给数组从小到大进行排序-d-反转数组-e-在数组61之后加入62、63、64"><a href="#九-、对数组testArray进行以下操作：a-从前面删除一个数字-b-从前面增加一个数字5-c-给数组从小到大进行排序-d-反转数组-e-在数组61之后加入62、63、64" class="headerlink" title="九 、对数组testArray进行以下操作：a.从前面删除一个数字 b.从前面增加一个数字5 c.给数组从小到大进行排序 d. 反转数组 e.在数组61之后加入62、63、64"></a>九 、对数组testArray进行以下操作：a.从前面删除一个数字 b.从前面增加一个数字5 c.给数组从小到大进行排序 d. 反转数组 e.在数组61之后加入62、63、64</h1><blockquote>
<p>考察常见的数组操作，给定的数组为[3,4,61,8,1]</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray=[<span class="number">3</span>,<span class="number">4</span>,<span class="number">61</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line">testArray.shift()</span><br><span class="line"><span class="comment">//b</span></span><br><span class="line">testArray.unshift(<span class="number">5</span>)</span><br><span class="line"><span class="comment">//c</span></span><br><span class="line">testArray.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b)</span><br><span class="line"><span class="comment">//d</span></span><br><span class="line">testArray.reverse()</span><br><span class="line"><span class="comment">// e.</span></span><br><span class="line">testArray.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="number">62</span>,<span class="number">63</span>,<span class="number">64</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>一部分手机不支持promise</title>
    <url>/2020/03/09/%E4%B8%80%E9%83%A8%E5%88%86%E6%89%8B%E6%9C%BA%E4%B8%8D%E6%94%AF%E6%8C%81promise/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<p>使用babel-polyfill,安装完成之后直接引用即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-polyfill</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>遇到的bug</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>在手机端测试遇到的BUG</title>
    <url>/2020/03/09/%E5%9C%A8%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%B5%8B%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84BUG/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>有一个功能是拖动侧边字母表，然后整个页面都一个自动滑动到所对应的字母表。在电脑上测试没有问题，但是用手机会遇到一个傻逼的bug，就是当我在拖动的时候，整个页面都会拖动，类似于平时用手机浏览微博等向下拉就会刷新时页面乡下拖一样的效果</p>
</blockquote>
<p>怎么解决呢？加上整个 .prevent 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@touchstart.prevent&#x3D;&quot;handleTouchStart&quot;</span><br></pre></td></tr></table></figure>

<hr>
<p>同时还引出了一个知识点，即vue的修饰符</p>
<p>1   .prevent   拦截默认事件<br>2   .passive   不拦截默认事件</p>
]]></content>
      <categories>
        <category>遇到的bug</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中使用swiper的问题</title>
    <url>/2020/03/09/vue%E4%B8%AD%E4%BD%BF%E7%94%A8swiper%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>发现使用的swiper插件经常性出现一个问题，就是不知道什么时候开始，loop就失效了。即不能循环。</p>
</blockquote>
<blockquote>
<p>百度后发现是因为使用了缓存的原因。 loop设置为true 则开启loop模式。loop模式：会在原本slide前后复制若干个slide(默认一个)并在合适的时候切换，让Swiper看起来是循环的， 可是在vue的v-for中时，异步加载的数据都还没有返回时，就先加载了Swiper组件并复制了sliper，导致loop失效</p>
</blockquote>
<p>解决办法,swiperList是axios获取到的数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span> <span class="attr">v-if</span>=<span class="string">'swiperList &amp;&amp; swiperList.length &gt; 0'</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>遇到的bug</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中click不生效</title>
    <url>/2020/03/09/vue%E4%B8%ADclick%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>本来没打算写这个，因为之前发现click不生效可以使用touchstart去代替，可是后来发现使用了touchstart后不能在滑动了，其实可以滑动，但是使用click的目的是为了点击后跳转到首页，所以在刚刚准备滑动时，就被跳转到了首页。</p>
</blockquote>
<blockquote>
<p>于是乎，搜索了一下，发现问题在于使用了一个插件：better-scroll</p>
</blockquote>
<p>只需要做如下配置即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.scroll=<span class="keyword">new</span> BScroll(<span class="keyword">this</span>.$refs.content,&#123; </span><br><span class="line">      mouseWheel: <span class="literal">true</span>, <span class="attr">click</span>: <span class="literal">true</span>, <span class="attr">tap</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>遇到的bug</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>点击图片显示画廊效果</title>
    <url>/2020/03/09/%E7%82%B9%E5%87%BB%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E7%94%BB%E5%BB%8A%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>看起来很复杂，实际上只是用到了v-show，v-show可以控制组件显示与否。其实项目不是最终目的，而是通过项目去掌握知识达到融汇贯通的效果。所以不要囫囵吞枣的将项目做完，而是时时反思。好了废话不多讲，先看效果图</p>
</blockquote>
<p><img src="/images/3.png" alt=""></p>
<blockquote>
<p>可以发现图片是居中显示的，其他地方都是黑色背景，并且这还是一个轮播效果。emmmmm ，好复杂</p>
</blockquote>
<hr>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><blockquote>
<p>首先来结解决这个css的问题，如何将整个北京变为黑色？其实在之前做search功能就用到了。当然了，还有这个图片是居中显示的，这里使用了flex，其实很多地方可以用到flex，反正能用flex就用。这里总结一下，直接看代码吧</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;style lang=<span class="string">"stylus"</span> scoped&gt;</span><br><span class="line">    .container</span><br><span class="line">        <span class="attribute">display</span> flex</span><br><span class="line">        <span class="attribute">flex-flow</span> column nowrap</span><br><span class="line">        <span class="attribute">justify-content</span> center</span><br><span class="line">        <span class="attribute">position</span> fixed</span><br><span class="line">        <span class="attribute">left</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">top</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">bottom</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">right</span> <span class="number">0</span></span><br><span class="line">        <span class="attribute">background-color</span> black</span><br><span class="line">        .wrapper</span><br><span class="line">            <span class="attribute">overflow</span> hidden</span><br><span class="line">            <span class="attribute">height</span> <span class="number">0</span></span><br><span class="line">            <span class="attribute">padding-bottom</span> <span class="number">56%</span></span><br><span class="line">            <span class="attribute">background-color</span> white</span><br><span class="line">            .img</span><br><span class="line">                <span class="attribute">width</span> <span class="number">100%</span></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote>
<p>可以发现这个轮播组件其实用的挺多的，并且在一个页面就显示了两个页面效果，这也可以拆分，以后再说</p>
</blockquote>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><blockquote>
<p>要想实现点击图片就显示画廊效果，就在图片上绑定事件，它可以改变某个值，然后在画廊上使用v-show，它使用相同的某个值去控制v-show显示。显示解决了，那么隐藏呢？这时在画廊的组件上也绑定一个事件，同样的可以改变某个值，然后去控制这个v-show的隐藏</p>
</blockquote>
]]></content>
      <categories>
        <category>vue项目需求</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动绑定事件</title>
    <url>/2020/03/09/%E6%BB%91%E5%8A%A8%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>需求：滑动右侧字母列表，手指停在哪屏幕就显示哪儿一个字母开头的城市列表</p>
</blockquote>
<p><img src="/images/2.png" alt=""></p>
<hr>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><blockquote>
<p>首先，给右侧字母表得先绑定三个事件。分别是touchstart、touchmove、touchend。</p>
</blockquote>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><blockquote>
<p>现在得需要知道手指滑倒的地方对对应的字母是什么。这就需要通过一些计算去得出。有一个解决办法是先计算出A与顶部的距离H，然后在算出每一个字母所占的高度h，然后计算手指与顶部的距离X，然后（X-H) / h。 如果计算出1.5，就代表是第二个字母，2.1就是第三个。</p>
</blockquote>
<blockquote>
<p>当然以上只是一种想法，具体实现看代码</p>
</blockquote>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><blockquote>
<p>具体算法有了，那么怎么实现呢？现在有几个问题需要解决。</p>
</blockquote>
<p>1  计算出值后，怎么通过这个值去找到对应的字母？类似与数组，求出了下标，怎么得出这个具体的值</p>
<p>在计算属性中通过for in 循环。  同时需要注意，之前在v-for中因为cities是对象，而现在得出了letters，所以可以改变循环的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">letters()&#123;</span><br><span class="line">    <span class="keyword">const</span> letters=[]</span><br><span class="line">    <span class="comment">// for...in 语句用于对数组或者对象的属性进行循环操作。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> <span class="keyword">this</span>.cities)&#123;</span><br><span class="line">        letters.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> letters</span><br><span class="line">    <span class="comment">// ["A","B",.......]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2 现在就可以开始写计算位置的代码了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算A与顶部的距离</span></span><br><span class="line"><span class="keyword">const</span> startY=<span class="keyword">this</span>.$refs[<span class="string">"A"</span>][<span class="number">0</span>].offsetTop</span><br><span class="line"><span class="comment">//计算当前滑动手指所在的地方与顶部的距离</span></span><br><span class="line"><span class="comment">//79是header和search的总高度</span></span><br><span class="line"><span class="comment">//所以touchY就是距离顶部的高度</span></span><br><span class="line"><span class="comment">//这里的e是touchmove被触发时传递的参数</span></span><br><span class="line"><span class="comment">//e.touches[0].clientX为横坐标</span></span><br><span class="line"><span class="keyword">const</span> touchY=e.touches[<span class="number">0</span>].clientY<span class="number">-79</span></span><br><span class="line"><span class="comment">// index为字母下标</span></span><br><span class="line"><span class="comment">//14为每一个字母所占的高度</span></span><br><span class="line"><span class="comment">//Math.floor为取整</span></span><br><span class="line"><span class="comment">//这里要格外注意 14为字母高度，但是还得算上margin、padding等  所以修改为19</span></span><br><span class="line"><span class="keyword">const</span> index=<span class="built_in">Math</span>.floor((touchY-startY)/<span class="number">19</span>)</span><br><span class="line"><span class="comment">//最后触发change事件</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"change"</span>,<span class="keyword">this</span>.letters[index])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue项目需求</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>点击绑定事件</title>
    <url>/2020/03/09/%E7%82%B9%E5%87%BB%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><blockquote>
<p>点击右边的字母，然后跳转到对应的字母的城市列表</p>
</blockquote>
<p>如图，点击A 就显示到A。   点击B就显示到B</p>
<p><img src="/images/2.png" alt=""></p>
<hr>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h3 id="第一步思路"><a href="#第一步思路" class="headerlink" title="第一步思路"></a>第一步思路</h3><blockquote>
<p>首先要获取到点击的是什么东西，比如点击A就要获取到这个A。那么这个e代表的是什么呢？e其实就是点击事件，然后通过e的属性去获取到这个a。   这里可以通过控制台去查看</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleLetterClick(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.innerText)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二步思路"><a href="#第二步思路" class="headerlink" title="第二步思路"></a>第二步思路</h3><blockquote>
<p>现在已经获取到了点击的东西，那么就要想把它传给谁。既然要让城市列表联动，那么就一定是传给这个列表组件。这里就会涉及到vue兄弟组件间的传值。</p>
</blockquote>
<blockquote>
<p>因为这两个是同父组件，所以不需要用到BUS总线的方式。直接将其传给父组件，然后在又父组件传递给子组件，这样就实现了兄弟组件间的传值</p>
</blockquote>
<blockquote>
<p>那么如何做呢？这里需要提到一个属性  emit。它用来向外传递事件。比如这个代码的意思是，每次点击时，向外触发change事件，并且传递这个值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">"change"</span>,e.target.innerText)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>那么如何去监听呢？假如是A组件使用emit，那么就到其父组件中的template中对应的模板中去监听。即当监听到change事件时，又触发handleLetterChange事件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">city-alphabet</span> <span class="attr">:cities</span>=<span class="string">"cities"</span> @<span class="attr">change</span>=<span class="string">"handleLetterChange"</span>&gt;</span><span class="tag">&lt;/<span class="name">city-alphabet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>然后将获取到的letter（即从子组件随着change事件传递过来的值）传给城市列表的子组件中。方法同使用mooc数据一样</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handleLetterChange(letter)&#123;</span><br><span class="line">    <span class="keyword">this</span>.letter=letter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步思路"><a href="#第三步思路" class="headerlink" title="第三步思路"></a>第三步思路</h3><blockquote>
<p>问题又来了，当这个值传递给子组件后，该怎么使用？</p>
</blockquote>
<blockquote>
<p>思路是当监听到letter有变化后，就立即让开头字母为letter值的列表马上显示出来。所以接下来就是如何监听的事儿了。这里用到了watch侦听器。</p>
</blockquote>
<blockquote>
<p>还有一个问题，就是如何去改变列表的显示。由于这里使用的是better-scroll插件，所以会用到一个api</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch:&#123;</span><br><span class="line">    letter()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.letter)&#123;</span><br><span class="line">            <span class="comment">// 需要获取的dom应该是整个area，而不是愚蠢的去获取title</span></span><br><span class="line">            <span class="comment">// 还有一点需要注意，如果是循环的，那么ref前面得加上冒号</span></span><br><span class="line">            <span class="comment">// 即写成 :ref</span></span><br><span class="line">            <span class="keyword">const</span> element=<span class="keyword">this</span>.$refs[<span class="keyword">this</span>.letter][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">this</span>.scroll.scrollToElement(element)</span><br><span class="line">            <span class="comment">// console.log(this.$refs) //&#123;A:Array(),B:Array(),.....&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止~</p>
]]></content>
      <categories>
        <category>vue项目需求</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>异步组件实现按需加载</title>
    <url>/2020/03/09/%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>click look more</p>
<a id="more"></a>

<blockquote>
<p>为什么要有这个东西呢，道理很简单，因为vue时单页应用，这回导致一个问题，就是第一次加载时会变得很慢，因为它在第一次加载时九八所有的页面就加载完了</p>
</blockquote>
<blockquote>
<p>假设有5个页面，那么第一就要加载5个页面，但是如果只想看第一个页面，那么其他4个页面时没有必要加载的，这样会浪费导致体验不行，影响性能。</p>
</blockquote>
<blockquote>
<p>所以，引入了按需加载，即访问那儿一个页面就加载哪儿一个 </p>
</blockquote>
<p><img src="/images/1.png" alt="测试hexo上传图片"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/03/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h2 id="正则表达式学习笔记"><a href="#正则表达式学习笔记" class="headerlink" title="正则表达式学习笔记"></a>正则表达式学习笔记</h2><a id="more"></a>

<h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><pre><code>现在想验证一串美国的邮政编码，格式为十进制代码：99999-9999</code></pre><p>不使用正则表达式代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isThisAZipCode</span>(<span class="params">candidate</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> candidate!==<span class="string">"string"</span>||candidate.length!=<span class="number">10</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"false"</span>)		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> n=<span class="number">0</span>;n&lt;candidate.length;n++)&#123;</span><br><span class="line">		<span class="keyword">let</span> c=candidate[n]</span><br><span class="line">		<span class="keyword">switch</span>(n)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">				<span class="keyword">if</span>(c&lt;<span class="string">"0"</span>||c&gt;<span class="string">"9"</span>)</span><br><span class="line">					<span class="built_in">console</span>.log(<span class="string">"false"</span>)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">				<span class="keyword">if</span>(c!=<span class="string">"-"</span>)</span><br><span class="line">					<span class="built_in">console</span>.log(<span class="string">"false"</span>)</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"true"</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种代码看起来很繁琐，这时就可以使用正则表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isThisAZipCode</span>(<span class="params">candidate</span>)</span></span><br><span class="line"><span class="function">    <span class="title">return</span> /^\<span class="title">d</span></span>&#123;<span class="number">5</span>&#125;-\d&#123;<span class="number">4</span>&#125;$/.test(candidate)</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式说明"><a href="#正则表达式说明" class="headerlink" title="正则表达式说明"></a>正则表达式说明</h2><pre><code>创建方法
1.字面量表达式
2.创建RegExp的实例

！！！当正则表达式在开发环境是明确的，推荐优先使用字面量语法；当需要在运行时动态创建字符串来构建正则表达式时，则使用构造函数的方式。</code></pre><ul>
<li>5个修饰符<ul>
<li>i 对大小写不敏感</li>
<li>g 查找所有匹配项</li>
<li>m 允许多行匹配</li>
<li>y 开启粘贴匹配</li>
<li>u 允许使用Unicode点转义符</li>
</ul>
</li>
</ul>
<p>在字面量末尾添加修饰符(如/test/ig),或者作为第2个参数传给RegExp构造函数(new RegExp(“ test”, “ig”))</p>
<h2 id="术语和操作符"><a href="#术语和操作符" class="headerlink" title="术语和操作符"></a>术语和操作符</h2><ul>
<li>精确匹配：必须要精准的匹配到完整的字符串    /test/</li>
<li>匹配字符集：<ul>
<li>只需要匹配其中的一个或者多个：[abc]</li>
<li>或者不匹配指定的这几个字符：[^abc]</li>
<li>限定范围：[a-z]</li>
</ul>
</li>
<li>转义：\</li>
<li>起止符号：？？？？</li>
<li>重复出现：如果想匹配4个重复的字符可以使用/aaaa/，那么如果要匹配任意数量的呢？<ul>
<li>指定可选字符（最多出现一次）：/t?est/   —&gt;test,est</li>
<li>指定字符必须出现最少一次：/t+est/     —&gt;test ttest tttest</li>
<li>指定字符必须出现0次1次或者多次：/t*est/     —&gt;est test ttest</li>
<li>指定重复次数：/a{4}/        —&gt;aaaa</li>
<li>指定循环次数的范围：/a{4,10}/        —&gt;aaaa aaaaa … aaaaaaaaaa</li>
<li>指定开放区间：/a{4,}/     —&gt;aaaa aaaaa … aaaaaaaaaaaaaa…</li>
<li>这些运算符都是贪婪的，即会匹配所有的可能，而非贪婪模式则只会进行最小限度的匹配： 如果有字符串aaa那么/a+/会匹配全部的a，如果非贪婪/a+?/那么只会匹配一个a</li>
</ul>
</li>
<li>预定义字符集：有些字符无法通过字面量表达出来<ul>
<li>\t:水平制表符 （相当于tab键）</li>
<li>\b:空格</li>
<li>\r:回车符</li>
<li>\f:换页符</li>
<li>\h:换行符</li>
<li>\d:等价于/0-9/</li>
<li>\D:匹配除了十进制数字外的任意字符。等价于/^0-9/</li>
<li>\w:等价于/0-9a-zA-Z_/</li>
<li>\W:匹配除了字母，下划线，数字。等价于/^0-9a-zA-Z_/</li>
<li>\s:匹配任意空白字符。</li>
<li>\S:匹配除了空白字符以外的任意字符。</li>
<li>\b:匹配单词边界。</li>
<li>\B:匹配单词内部。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序学习笔记</title>
    <url>/2020/03/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>将持续更新~</p>
<a id="more"></a>

<blockquote>
<ul>
<li>就近原则，在写wxss时页面级的样式会覆盖应用级的样式，其实和css一样。json同理</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>页面层级最好不要超过5层，因为层级太多用户体验不好</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在每次增加或者减少页面后都需要对app.json的pages数组进行修改</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>有个很有意思的技巧，因为在开发初期，无法快速直接创建页面的各个文件，这时可以在app.json中的pages里面增加这个页面，然后文件树就会自动创建好</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在页面的json中，不能为空。要么写一个大括号，要么就删除</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>wxml中添加图片如果没有设置wxss则会显示默认的尺寸：300*225</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>text组件内只支持text的嵌套，并且除了文本节点以外的其他节点都无法被长按选中</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>rpx和px的区别在于rpx会随着机型的变化而改变，就是自适应</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>swiper组件中，只能放swiper-item，放其他的东西会出现未定义错误。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>要想设置swiper中banner的宽高，只能在swiper中设置，而不能在swiper-item或者image中设置，这样是无效的，因为swiper是最外面的容器，swiper-item会自动100%</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>swiper中也不用设置宽度，根据css的流体特性，是会自动铺满整个屏幕的，所以如果banner没有铺满，只需要设置相应的图片即可</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>页面配置中，只能设置app.json中window对应的配置项，以决定本页面的窗口表现，所以无需写window这个属性</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在wxss中，如果设置了image ==&gt; width:100%;height:100%;    ，就会出现一个bug，就是image中的图片不会显示，可能的原因未知，根据猜测应该是image标签自身的默认属性。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>水平居中推荐使用弹性盒子而不是vertical-align。代码如下display: flex;flex-direction: row;align-items: center;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在设置字体颜色时不要设置纯黑色，可以使用#333</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>关于页面的js，生命周期函数执行顺序onload—&gt;onshow—&gt;onready</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>onunload和onhide在多页面情况下会执行</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>onshare在点击转发之后就会立即执行，并且同时会触发onhide。因为转发的页面会覆盖在当前页面上</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>生命周期在有经验之后再来理解会好一点</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>小程序是不存在DOM节点的</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在小程序真实开发中数据是不能绑定在wxml中的，通过数据绑定从js中的数据可以直接显示在wxml中，语法是双花括号，里面填在js中data中定义的数据名</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>DOM优先和数据优先</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>小程序是单向数据绑定，即JS到wxml，如果wxml改变了JS是不会自动更新的，但是可以通过事件的方式。这里要注意是自动~</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>this.setData(obj_name),这样在服务器获取的属性就不用再data里面定义。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>js中，非空字符串会判定为false，有意思的在于之前的swiper组件，设置了autoplay=’true’和autoplay=’false’是一样的，为什么呢？因为这里是一个字符串形式，所以在设置swiper属性时有很多种做法，比如要设置false，可以加上两个双括号，或者是一个非空字符</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>关于双花括号的用法可以参考框架-视图层-wxml-数据绑定</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>wx:if 和 wx:for 后面数据绑定都要加引号</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>（条件渲染）wx:if在组件里可以控制该组件的显示与否，但是也要用到数据绑定，即花括号中的变量名的值随js中而变化</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>（列表渲染）wx:for指定数组，wx:for-item指定数组下面的元素<br>ps:   这里wx:for-item其实也可以不写，只写在数据绑定中加上任意前缀就可以，因为他会为你自动推断出wx:for-item就是这个任意的前缀。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>点击按钮跳转页面并且保留当前页面使用API：   wx.navigateTo</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>关闭当前页面，跳转到应用内的某个页面使用API：   wx.redirectTo</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>没有特殊需求不要使用button，可以使用view</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>垂直水平居中（flex）<br>  display:flex;<br>  flex-direction: column;<br>  align-items: center;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在考虑使用rpx和px单位时，要考虑是否需要自适应，比如文章和图片之间想保持一个固定的间距，就应该使用px而不是盲目使用rpx</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>标题使用#333，正文使用#666</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>数据绑定只能在默认data里面定义，不能是自己定义的</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果从服务器返回一个数组变量，并且数组赋值给了一个变量x,这时不能用this.setData(x)，因为返回到默认data里面的必须是一个名字并且有属性，但是这个x是一个临时的变量，所以不能直接这么写。可以对x赋值一个y，即y:x，让y成为x的变量名，同时，在wxml的wx:for中，也要写上y而不是x。</li>
</ul>
</blockquote>
<p>ps:  其实直接在this.setData(x)中给x加上{}就可以了。  但是这是ES6语法中简写对象的形式<br>原理是，对象名和对象值相同时，可以简化只写一个。</p>
<blockquote>
<ul>
<li>wx:for-item和wx:for一起用，后者指定数组，前者指定数组中的元素，同时在wxml中数据绑定也要加上前缀wx:for-item指定的值。   这里wx:for-item默认值是item</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>要想知道当前是数组第几位，可以使用wx:for-index=”idx”，这里idx可以换成任意，然后双括号idx就可以了。这里index是默认值</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>wx.navigateTo和wx.redirectTo区别在于前者跳转页面后会后返回前页面的按钮，后者没有。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>bind和catch的区别是bind会向上冒泡（父元素绑定事件会随之发生），而catch只捕捉当前元素。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>alt + shift + f  快速格式化代码格式</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>require方法只能使用相对路径，用绝对路径是找不到的</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>数据都需要从服务器获取，如果没有服务器，则可以新键一个目录，在新目录里新键JS文件，将所有数据放在文件里，然后</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    postList:local_database</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>local_database是数据的变量名，postList是他的对象名<br>然后在相应的JS文件中写如下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postsData=<span class="built_in">require</span>(<span class="string">"../../data/posts-data.js"</span>);</span><br><span class="line"><span class="comment">//写在onload函数中</span></span><br><span class="line"><span class="keyword">this</span>.setData(&#123;</span><br><span class="line">      posts_key:postsData.postList;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>template模板写在wxml里面 </li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>这里的is等于模板名字  ps：import组件也需要/</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template is=<span class="string">"postItem"</span> /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>css模板化,引号中是模板化的文件名</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"post-item/post-item-template.wxss"</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>只有连字符会被默认转换成驼峰书写形式，自己写的驼峰会被默认成小写</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>js文件必须要有东西，不能为空的</li>
</ul>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
<blockquote>
<p>+</p>
</blockquote>
]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据—变量—内存概念辨析</title>
    <url>/2020/03/09/%E6%95%B0%E6%8D%AE%E2%80%94%E5%8F%98%E9%87%8F%E2%80%94%E5%86%85%E5%AD%98%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90/</url>
    <content><![CDATA[<p>简单来说，内存中存储着变量，每个变量都有变量名和变量值，变量值存储堆内存，变量名存储在栈内存并且有对应的值的地址，通过这个地址可以查找到这个值。</p>
<a id="more"></a>
<h2 id="什么是数据？"><a href="#什么是数据？" class="headerlink" title="什么是数据？"></a>什么是数据？</h2><p>存储在内存中代表着特定信息的东西，本质上是0101…..。</p>
<p>特点：可传递   可运算</p>
<h2 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h2><p>内存条通电之后产生的可存储的数据的空间（临时的，因为在断电后内存条的空间将消失）。</p>
<p>内存分为堆和栈，堆内存存储变量名，栈内存存储对象</p>
<p>这里又能涉及到关于JS代码的编译问题，因为JS是脚本语言，和C JAVA等不同，在以后博文中在详细讨论。</p>
<h2 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h2><p>可变化的量，由变量名和变量值组成。变量名实质上是存储着对象的地址，变量值则存储这个对象的数据</p>
<h2 id="三者的关系"><a href="#三者的关系" class="headerlink" title="三者的关系"></a>三者的关系</h2><p>内存是用来存储数据的空间，变量是内存的标识。</p>
<h3 id="关于赋值和内存的问题"><a href="#关于赋值和内存的问题" class="headerlink" title="关于赋值和内存的问题"></a>关于赋值和内存的问题</h3><p>Q：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=xxx;</span><br></pre></td></tr></table></figure>
<p>a保存的是什么？</p>
<p>当a保存一个基本数据时，保存的就是这个数据<br>当a保存一个对象时，保存的是这个对象的地址值<br>当a保存一个变量时，保存的是这个变量所保存的东西</p>
<h3 id="关于引用变量赋值的问题"><a href="#关于引用变量赋值的问题" class="headerlink" title="关于引用变量赋值的问题"></a>关于引用变量赋值的问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;<span class="attr">age</span>:<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b=a;</span><br><span class="line">a=&#123;<span class="attr">age</span>:<span class="number">13</span>,name=<span class="string">"xx"</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码很容易出错，误以为第三行代码是在原来的对象上重新赋值，导致觉得a=b=新对象，其实这里的a是指向了这个新对象，但是b还是指向的原来的那个对象，所以b.name为undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;<span class="attr">age</span>:<span class="number">12</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b=a;</span><br><span class="line">a=&#123;<span class="attr">name</span>:<span class="string">"bob"</span>,<span class="attr">age</span>:<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b.age,a.name,a.age,b.name);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj=&#123;<span class="attr">age</span>:<span class="number">16</span>&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.age);</span><br><span class="line">&#125;</span><br><span class="line">fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(a.age);</span><br></pre></td></tr></table></figure>

<p>这里也很容易出错，将a.age认为是16。fn(a)将a赋值给了obj，所以在执行函数时obj和a都指向同一个对象，但是函数里面的obj={age:16}将obj指向了另外一个对象，可是a还是指向原对象，所以a.age=13。</p>
<p>错误原因是以为obj为形参，在函数内执行的是a。通过下面的代码可以看出其实obj只是复制了a的值，但是对a实际上并没有影响</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    x+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>这里a依然输出1，并没有改变。突然想到，假如将上面的obj={age:16}改成obj.age=16。在测试之后发现a的值被更改了。发现这是因为两个对象的值其实都是指向对象的地址，在修改成=之后，是在原有的对象上修改的，所以a会改变，但是没修改之前，是将age=16重新赋值给了obj，所以没有改变！！！</p>
<p>这个现象值得好好看看想想！</p>
<p>还有个误区，在传递参数时，并不是将变量直接传进去，而是拷贝一份或者说复制一份给形参然后传递进去，跟原参数没有半毛钱关系，这也就解释了上面最近的代码块为什么a还是1！</p>
<h3 id="在js调用函数传递变量参数时，是值传递还是引用传递？"><a href="#在js调用函数传递变量参数时，是值传递还是引用传递？" class="headerlink" title="在js调用函数传递变量参数时，是值传递还是引用传递？"></a>在js调用函数传递变量参数时，是值传递还是引用传递？</h3><p>还用上面的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    x+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>在这里a和x都是新的变量，在fn(a)的时候是将a的值传递给x，在函数内执行的时候，这个x是值在操作，即3，然后又来一个x，但是只是在函数内作用，函数结束后就被释放了。   </p>
<p>当然了，关于这个问题得分情况，因为传递进去可能是基本数据类型，也可能是对象数据类型，前者是值传递，后者是引用传递（地址值）。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的程序设计(基于ES5)</title>
    <url>/2020/03/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<hr>
<h2 id="深入理解JS中的面向对象程序设计思想，包括各种设计模式"><a href="#深入理解JS中的面向对象程序设计思想，包括各种设计模式" class="headerlink" title="深入理解JS中的面向对象程序设计思想，包括各种设计模式"></a>深入理解JS中的面向对象程序设计思想，包括各种设计模式</h2><a id="more"></a>

<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>创建一个最简单的对象方法就是直接创建一个Object的实例，然后在去添加属性和方法,最早期JS创建对象的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">p.name=<span class="string">"edison"</span></span><br><span class="line">p.age=<span class="number">22</span></span><br><span class="line">p.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>后来对象字面量称为主流，改写以上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p=&#123;</span><br><span class="line">    name:<span class="string">"edison"</span></span><br><span class="line">    age:<span class="number">22</span></span><br><span class="line">    sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><pre><code>ES在定义只有内部才用的特性时，描述了属性的各种特征。定义这些特性是为了实现JS引擎用的，所以在JS中不能直接访问他们，将特性用两对中括号括起来。

共有两种属性类型：数据属性和访问器属性</code></pre><h4 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h4><p>数据属性包含一个数据值的位置，这个位置可以写入和读取，共有4个特性描述</p>
<ul>
<li>[[Configurable]] : 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性</li>
<li>[[Enumerable]]:表示能否通过for-in循环返回属性。</li>
<li>[[Writable]]：表示能否修改属性的值。</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</li>
</ul>
<p>对于像前面例子中那样直接在对象上定义的属性，它们的[[Configurable]]、[[Enumerable]]和[[Writable]]特性都被设置为true，而[[Value]]特性被设置为指定的值。</p>
<p>要修改默认属性的值，需要使用Object.defineProperty()，接收三个参数：属性的所在的对象，属性的名字和一个描述符(descriptor)对象。其中descriptor的值必须是数据属性的4个特性中的一个或多个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p=&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(p,<span class="string">"name"</span>,&#123;</span><br><span class="line">	writable:<span class="literal">false</span>,</span><br><span class="line">	value:<span class="string">"edison"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p.name)   <span class="comment">//==&gt;edison</span></span><br><span class="line">p.name=<span class="string">"kobe"</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name)   <span class="comment">//==&gt;edison    因为设置了writable为false，即无法修改属性的值</span></span><br></pre></td></tr></table></figure>

<p>也就是说，可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。 在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。多数情况下，可能都没有必要利用Object.defineProperty()方法提供的这些高级功能。不过，理解这些概念对理解JavaScript对象却非常有用。</p>
<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><p>访问器属性不包含数据值，而是包含一对getter和setter函数(两者都是非必须的)</p>
<p>在读取访问器属性时会调用getter，其负责返回有效值；在写入访问器属性时会调用setter函数并且传入新值，决定如何处理数据</p>
<ul>
<li>[[Configurable]] : 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性</li>
<li>[[Enumerable]]:表示能否通过for-in循环返回属性。<br>[[Get]]：在读取属性时调用的函数。默认值为undefined。<br>[[Set]]：在写入属性时调用的函数。默认值为undefined。</li>
</ul>
<p>访问器属性不能直接定义，必须使用Object.defineProperty</p>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><pre><code>由于为对象定义多个属性的可能性很大，ECMAScript 5又定义了一个Object.defineProperties\(\)方法。通过这个方法可以利用描述符一次性定义多个属性。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book=&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year:&#123;</span><br><span class="line">        value:<span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition:&#123;</span><br><span class="line">        value:<span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year:&#123;</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><pre><code>抽象了创建对象的具体过程。因为js无法创建类，故发明了一种函数，用函数来封装以特定接口创建对象的细节</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">	o.name=name</span><br><span class="line">	o.age=age</span><br><span class="line">	o.job=job</span><br><span class="line">	o.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=createPerson(<span class="string">"kobe"</span>,<span class="number">40</span>,<span class="string">"player"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)    <span class="comment">//==&gt;kobe</span></span><br></pre></td></tr></table></figure>

<p>虽然工厂模式解决了创建多个相似对象的问题，但是没有解决对象的识别问题（即怎样知道一个对象的类型）</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><pre><code>ES中的构造函数可以用来创建特定类型的对象（构造函数名开头要使用大写）。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name=name</span><br><span class="line">	<span class="keyword">this</span>.age=age</span><br><span class="line">	<span class="keyword">this</span>.job=job</span><br><span class="line">	<span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">"kobe"</span>,<span class="number">40</span>,<span class="string">"player"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)</span><br></pre></td></tr></table></figure>

<p>在创建Person的新实例时，必须使用new操作符，会经过4个步骤：</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象</li>
<li>执行构造函数中的代码</li>
<li>返回新对象</li>
</ol>
<p>在p1中，有一个constructor属性指向Person，对象的constructor属性最初使用来标识对象类型的，但是提到检测对象类型，还是instanceof操作符更可靠！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.constructor===Person) <span class="comment">//==&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor===<span class="built_in">Object</span>) <span class="comment">//==&gt;false</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person) <span class="comment">//==&gt;true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">//==&gt;true</span></span><br></pre></td></tr></table></figure>

<pre><code>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型，这也是构造函数模式胜过工厂模式的地方</code></pre><h4 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h4><pre><code>构造函数与其他函数唯一区别就是调用方式。但是构造函数也是函数，不存在定义构造函数的特殊语法。任何函数重要通过new来调用，那么它就可以当作构造函数。反之任何函数不通过new调用，那么它跟普通函数也不会有什么两样</code></pre><h4 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h4><pre><code>主要问题在于每个方法在每个实例上都要重新创建。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种声明是等价的</span></span><br><span class="line"><span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">this</span>.sayName=<span class="keyword">new</span> <span class="built_in">Function</span>()</span><br></pre></td></tr></table></figure>

<p>这样没有必要，故可以将方法放到构造函数外部来解决。但是假如有很多方法，就需要在外部定义很多方法，这样一来就完全没有封装性可言！</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><pre><code>每个函数都有一个原型prototype属性，这个属性是一个指针，指向由构造函数创建的实例的原型对象。</code></pre><p>这里直接将方法添加到Person的prototype属性中，构造函数成了空的，实际上所有的实例都是共享的，即创建出来的实例的属性方法都是一样的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name=<span class="string">"kobe"</span></span><br><span class="line">Person.prototype.age=<span class="number">40</span></span><br><span class="line">Person.prototype.job=<span class="string">"player"</span></span><br><span class="line">Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person()</span><br><span class="line">p1.sayName()</span><br></pre></td></tr></table></figure>

<h4 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h4><pre><code>无论什么时候，只要创建了一个新的函数，就会生成一个prototype属性，其指向函数的原型对象。默认情况下，所有原型对象都会获得一个constructor属性，其指向prototype所在。</code></pre><p>p1中会有一个[prototype],虽然无法访问，但是可以通过isPrototypeOf方法判断是否与原型对象存在关系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(p1))  ==&gt;<span class="comment">//TRUE   因为p1内部有一个指针指向Person.prototype</span></span><br></pre></td></tr></table></figure>

<p>在ES5中，有一个Object.getPrototypeOf方法，返回[[prototype]]的值，又因为其指向Person.prototype,实际返回对象原型（非常重要）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(p1).name)   ==&gt;  <span class="comment">//"kobe"</span></span><br></pre></td></tr></table></figure>

<p>每当代码需要读取某个属性时，都会执行一次搜索，即找到需要搜索的属性名。搜索先从实例开始，如果找到了则返回该属性值；反之则继续搜索指针指向的原型对象，如果找到了则返回其属性值。</p>
<p>前面说过，原型最初只包含constructor属性，而改属性也是共享的，因此可以通过对象实例来访问。虽然可以通过实例访问保存在原型对象中的值，但是不能通过实例去修改。</p>
<p>假如在实例中添加了一个属性，恰好原型中也存在相同属性，则会在实例中创建它，自动屏蔽原型中的那个属性。实际上原理和上面说的一样，即搜索机制，先外后里。即使将设置过的实例属性设置为null，也不会将其回收！不过可以使用delete操作符去删除！</p>
<p>hasOwnProperty方法可以检测一个属性是存在与实例中，还是存在于原型中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.hasOwnProperty(<span class="string">"name"</span>))</span><br></pre></td></tr></table></figure>

<h4 id="原型与in操作符"><a href="#原型与in操作符" class="headerlink" title="原型与in操作符"></a>原型与in操作符</h4><pre><code>有两种方式去使用in操作符：单独使用和在for-in循环中。</code></pre><p>单独使用时，in操作符会在通过对象能够访问给定属性时返回true，与属性存在于原型还是实例无关。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> Person)   <span class="comment">//==&gt;true</span></span><br></pre></td></tr></table></figure>

<h4 id="更简洁的原型语法"><a href="#更简洁的原型语法" class="headerlink" title="更简洁的原型语法"></a>更简洁的原型语法</h4><p>重写之前的代码。之前说过，没创建一个函数，就会同时创建它的原型对象，这个对象也会获得constructor属性指向函数。但是这里的写法完全重写了默认的原型对象，故使得constructor不再指向Person。</p>
<p>如果constructor的值真的很重要，则可以加上如下代码（用注释写出）.但是这样会使得它的[[Enumerable]]特性被设置为true。但是原生的constructor属性是不可以枚举的，因此可以试试Object.defineProperty方法，同样用注释写出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    <span class="comment">//constructor:Person,</span></span><br><span class="line">	name:<span class="string">"kobe"</span>,</span><br><span class="line">	age:<span class="number">40</span>,</span><br><span class="line">	job:<span class="string">"player"</span>,</span><br><span class="line">	sayName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Object.defineProperty(Person.prototype,"constructor",&#123;</span></span><br><span class="line"><span class="comment">//     enumerable:false,</span></span><br><span class="line"><span class="comment">//     value:Person</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>

<h4 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h4><pre><code>因为原型对象和构造函数和实例都是通过指针来连接的，这种连接是松散的。如果重写了原型对象，则实例的指针还是指向原来的原型对象，但是构造函数指向了新的原型对象，可是构造函数和实例之间没有并没有关联。虽然新旧两个原型对象constructor都指向构造函数Person，但是实例还是指向的原来的。</code></pre><h4 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h4><pre><code>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、Array、String，等等）都在其构造函数的原型上定义了方法。 </code></pre><h4 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h4><pre><code>原型模式省略了构造函数的传参，使得每个实例都都具有相同的属性，但是这不是最大的缺点。最大的问题在于其共享本质导致的。</code></pre><p>这种共享对于函数来说非常合适！但是对于包含引用类型的属性来说，问题突出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">	<span class="keyword">constructor</span>:Person,</span><br><span class="line">	name:"kobe",</span><br><span class="line">	age:40,</span><br><span class="line">	job:"player",</span><br><span class="line">	sayName:function()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;,</span><br><span class="line">	friends:[<span class="string">"jordan"</span>,<span class="string">"macRady"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1=<span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Person()</span><br><span class="line">p1.friends.push(<span class="string">"james"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.friends)  <span class="comment">//==&gt;[ 'jordan', 'macRady', 'james' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.friends)  <span class="comment">//==&gt;[ 'jordan', 'macRady', 'james' ]</span></span><br></pre></td></tr></table></figure>

<p>可以看到只对p1进行了push操作，但是同时也影响了p2！因为friends存在于Person.prototype中，修改了p1.friends.push也意味着p2的也被修改了，所以又出来一种新的设计模式！</p>
<h3 id="组合使用构造函数和原型模式"><a href="#组合使用构造函数和原型模式" class="headerlink" title="组合使用构造函数和原型模式"></a>组合使用构造函数和原型模式</h3><pre><code>构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性。</code></pre><p>重写之前的代码,分工合作.这也是用来定义引用类型的默认模式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,name,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.age=age</span><br><span class="line">	<span class="keyword">this</span>.name=name</span><br><span class="line">	<span class="keyword">this</span>.job=job</span><br><span class="line">	<span class="keyword">this</span>.friends=[<span class="string">"jordan"</span>,<span class="string">"macRady"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">	<span class="keyword">constructor</span>:Person</span><br><span class="line">	sayName:function()&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><pre><code>构造加原型显得封装度不够，故动态原型模式把所有的信息都封装在了构造函数中</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,name,job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.age=age</span><br><span class="line">	<span class="keyword">this</span>.name=name</span><br><span class="line">	<span class="keyword">this</span>.job=job</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName!=<span class="string">"function"</span>)&#123;</span><br><span class="line">        Person.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><pre><code>通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。但是不建议使用</code></pre><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><pre><code>道格拉斯•克罗克福德（Douglas Crockford）发明了JavaScript中的稳妥对象（durable objects）这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不使用new操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下。</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code>ES只支持实现继承，其依靠原型链来实现</code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><pre><code>基本思想是利用原型让一个引用类型继承另外一个引用类型的属性和方法。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"this is Super"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype=<span class="keyword">new</span> Super()</span><br><span class="line"></span><br><span class="line">Sub.prototype.say()   <span class="comment">//==&gt;Sub继承了Super的方法</span></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程--类的创建，数据的封装</title>
    <url>/2020/03/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="ES6之前"><a href="#ES6之前" class="headerlink" title="ES6之前"></a>ES6之前</h2><p>在ES6之前创建一个类有两种方式。第一种是常见的使用this，第二种是通过类的原型上添加属性和方法。</p>
<a id="more"></a>
<p>第一种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Book=<span class="function"><span class="keyword">function</span>(<span class="params">id,bookname,price</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id=id;</span><br><span class="line">    <span class="keyword">this</span>.bookname=bookname;</span><br><span class="line">    <span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Book.prototype=&#123;</span><br><span class="line">    display:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过this和prototype两种方式上的差异"><a href="#通过this和prototype两种方式上的差异" class="headerlink" title="通过this和prototype两种方式上的差异"></a>通过this和prototype两种方式上的差异</h3><p>通过this添加的属性和方法是在当前对象上添加的，但是JS是基于原型的语言，所以，每创建一个对象时，都会有一个原型用于指向其继承的属性和方法。故在使用这些方法时，需要通过对象本身的prototype去一级一级的查找来得到。</p>
<p>即通过this定义的，是该对象本身所拥有的。但是通过prototype定义的，则是通过对象的prototype去访问得到的，故每次通过类创建一个新对象时，这些通过prototype定义的东西是不会再次创建的。</p>
<p>表格中prototype和_proto_指向Book prototype,constructor指向Book。</p>
<p>constructor是一个属性，当创建一个对象时都会为其创建一个原型对象prototype，在prototype对象中又会创建一个constructor属性，那么这个属性指向的就是拥有整个原型对象的对象</p>
<table>
<thead>
<tr>
<th align="center">book</th>
<th align="center">Book</th>
<th align="center">Book prototype</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_proto_</td>
<td align="center">prototype</td>
<td align="center">constructor</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">id</td>
<td align="center">display</td>
</tr>
<tr>
<td align="center">bookname</td>
<td align="center">bookname</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">price</td>
<td align="center">price</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>在ES6中可以直接使用Class创建，继承使用extends，这里不详细讨论ES6语法。</p>
<h2 id="属性与方法封装"><a href="#属性与方法封装" class="headerlink" title="属性与方法封装"></a>属性与方法封装</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Book=<span class="function"><span class="keyword">function</span>(<span class="params">id,name,price</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkId</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.getPrice=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.setName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.setPrice=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//对象公有属性</span></span><br><span class="line">    <span class="keyword">this</span>.id=id;</span><br><span class="line">    <span class="comment">//对象公有方法</span></span><br><span class="line">    <span class="keyword">this</span>.copy=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">this</span>.setName(name);</span><br><span class="line">    <span class="keyword">this</span>.setPrice(price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类的外部通过点语法和通过prototype定义的属性和方法以及上面所写代码进行测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Book=<span class="function"><span class="keyword">function</span>(<span class="params">id,bookname,price</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">alt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"xxx"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.id=id;</span><br><span class="line">    <span class="keyword">this</span>.bookname=bookname;</span><br><span class="line">    <span class="keyword">this</span>.price=price;</span><br><span class="line">    <span class="keyword">this</span>.getId=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// console.log("new time");</span></span><br><span class="line">        <span class="built_in">console</span>.log(alt());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过点语法添加属性和方法，称为类静态公有属性和方法</span></span><br><span class="line">Book.isChinese=<span class="literal">true</span>;</span><br><span class="line">Book.resetTime=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"new time"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过原型添加属性和方法</span></span><br><span class="line">Book.prototype=&#123;</span><br><span class="line">    isJSBook:<span class="literal">false</span>,</span><br><span class="line">    display:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"display"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TEST</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="keyword">new</span> Book(<span class="number">11</span>,<span class="string">"JS"</span>,<span class="number">100</span>);</span><br><span class="line"><span class="comment">//访问不到类的私有属性</span></span><br><span class="line"><span class="built_in">console</span>.log(b.num);</span><br><span class="line"><span class="comment">//访问不到类的私有方法</span></span><br><span class="line"><span class="built_in">console</span>.log(b.alt);</span><br><span class="line"><span class="comment">//可以访问类的公有属性和方法</span></span><br><span class="line"><span class="built_in">console</span>.log(b.isJSBook);</span><br><span class="line"><span class="built_in">console</span>.log(b.display());</span><br><span class="line"><span class="comment">//访问不到类类静态公有属性</span></span><br><span class="line"><span class="built_in">console</span>.log(b.isChinese);</span><br><span class="line"><span class="comment">//访问不到类静态公有方法</span></span><br><span class="line"><span class="comment">// b.resetTime();</span></span><br><span class="line"><span class="comment">//通过特权方法调用私有变量成功</span></span><br><span class="line">b.getId();</span><br><span class="line"><span class="comment">//直接通过实例化对象调用私有变量失败,通过类直接调用也失败</span></span><br><span class="line"><span class="comment">//b.alt();</span></span><br><span class="line"><span class="comment">// Book.alt();</span></span><br></pre></td></tr></table></figure>

<p>总结：<br>1.私有变量和方法均不能被外面所调用，只能被内部特权方法所调用，故特权方法因此得名。<br>2.类静态公有属性方法对象不能访问。<br>3.通过prototype定义的属性方法可以访问是因为类和实例化的对象的prototype指向的都是同一个对象</p>
<h2 id="闭包实现类的静态变量"><a href="#闭包实现类的静态变量" class="headerlink" title="闭包实现类的静态变量"></a>闭包实现类的静态变量</h2><p>之所以把上述一些js变量和函数称为“静态”，是借用了Java的提法。这些“静态”变量和方法被保存在闭包中，在内存中是唯一的，不会随着该函数副本的增加而增加。如果一个函数需要被实例化多次，但其中的一些内部函数并不需要访问任何实例数据，从节省内存的角度考虑，可采用构建静态函数的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">let</span> Rabbit=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 静态私有变量</span></span><br><span class="line">    <span class="keyword">let</span> rabbitNum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">myName,myFavoriteFood,myAddress</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 私有变量</span></span><br><span class="line">        <span class="keyword">let</span> name,</span><br><span class="line">            food,</span><br><span class="line">            address;</span><br><span class="line">        <span class="comment">// 私有方法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">checkPassword</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"password:123"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 特权方法</span></span><br><span class="line">        <span class="keyword">this</span>.setName=<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            name=newName;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.setFood=<span class="function"><span class="keyword">function</span>(<span class="params">newFood</span>)</span>&#123;</span><br><span class="line">            food=newFood;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.getFood=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> food;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.setAddress=<span class="function"><span class="keyword">function</span>(<span class="params">newAddress</span>)</span>&#123;</span><br><span class="line">            address=newAddress;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.getAddress=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> address;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.check=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            checkPassword();</span><br><span class="line">        &#125;;</span><br><span class="line">        rabbitNum++;</span><br><span class="line">        <span class="keyword">this</span>.seeNumber=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"rabbitNum="</span>+rabbitNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setName(myName);</span><br><span class="line">        <span class="keyword">this</span>.setFood(myFavoriteFood);</span><br><span class="line">        <span class="keyword">this</span>.setAddress(myAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公有方法</span></span><br><span class="line">Rabbit.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello my name is"</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">&#125;</span><br><span class="line">Rabbit.prototype.checkP=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.check();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态公有属性</span></span><br><span class="line">Rabbit.eatBreakfast=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"all rabbits are eating"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> rabbit1=<span class="keyword">new</span> Rabbit(<span class="string">"小明"</span>,<span class="string">"牛肉"</span>,<span class="string">"中国"</span>);</span><br><span class="line"><span class="keyword">let</span> rabbit2=<span class="keyword">new</span> Rabbit(<span class="string">"KOBE"</span>,<span class="string">"CHICKEN"</span>,<span class="string">"USA"</span>);</span><br><span class="line"><span class="keyword">let</span> rabbit3=<span class="keyword">new</span> Rabbit(<span class="string">"OBAMA"</span>,<span class="string">"BEEF"</span>,<span class="string">"USA"</span>);</span><br><span class="line">rabbit1.sayHello();</span><br><span class="line">rabbit1.seeNumber();</span><br><span class="line">rabbit2.sayHello();    </span><br><span class="line">rabbit3.sayHello();</span><br></pre></td></tr></table></figure>

<p>这样的写法看起来使通过原型添加的方法和属性脱离了闭包，可以这样修改一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Rabbit=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 静态私有变量</span></span><br><span class="line">    <span class="keyword">let</span> rabbitNum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_rabbit</span>(<span class="params">myName,myFavoriteFood,myAddress</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">let</span> name,</span><br><span class="line">            food,</span><br><span class="line">            address;</span><br><span class="line">        <span class="comment">// 私有方法</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">checkPassword</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"password:123"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 特权方法</span></span><br><span class="line">        <span class="keyword">this</span>.setName=<span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;</span><br><span class="line">            name=newName;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.setFood=<span class="function"><span class="keyword">function</span>(<span class="params">newFood</span>)</span>&#123;</span><br><span class="line">            food=newFood;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.getFood=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> food;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.setAddress=<span class="function"><span class="keyword">function</span>(<span class="params">newAddress</span>)</span>&#123;</span><br><span class="line">            address=newAddress;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.getAddress=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> address;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">this</span>.check=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            checkPassword();</span><br><span class="line">        &#125;;</span><br><span class="line">        rabbitNum++;</span><br><span class="line">        <span class="keyword">this</span>.seeNumber=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"rabbitNum="</span>+rabbitNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setName(myName);</span><br><span class="line">        <span class="keyword">this</span>.setFood(myFavoriteFood);</span><br><span class="line">        <span class="keyword">this</span>.setAddress(myAddress);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 公有方法</span></span><br><span class="line">	_rabbit.prototype.sayHello=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">"hello my name is"</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">	&#125;</span><br><span class="line">	_rabbit.prototype.checkP=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.check();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 静态公有属性</span></span><br><span class="line">	_rabbit.eatBreakfast=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">"all rabbits are eating"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _rabbit;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="创建对象的安全模式"><a href="#创建对象的安全模式" class="headerlink" title="创建对象的安全模式"></a>创建对象的安全模式</h2><p>在实例化一个对象时，忘记写上new了会出错。如果没有写的话，实例化的变量是什么呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Book=<span class="function"><span class="keyword">function</span>(<span class="params">time,name,price</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.time=time;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.price=price;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b=Book(<span class="string">"2019"</span>,<span class="string">"JS"</span>,<span class="string">"100"</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码没有写new，故肯定不是Book类的一个实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.time);  <span class="comment">//2019</span></span><br></pre></td></tr></table></figure>

<p>首先，new关键字的作用可以看做是对当前对象的this的赋值，但是测试中没有使用new，故就会直接执行这个Book的代码，这时，Book的作用域是全局的，所以，当前对象是全局对象window。</p>
<p>稍微修改一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Book=<span class="function"><span class="keyword">function</span>(<span class="params">time,name,price</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> Book)&#123;</span><br><span class="line">        <span class="keyword">this</span>.time=time;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.price=price;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Book(time,name,price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里使用instanceof来判断当前对象是否为其实例化对象，如果不是，则重新创建这个对象</p>
]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式</title>
    <url>/2020/03/09/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>简单工厂模式又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象</p>
<a id="more"></a>
<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>在创建了很多类的时候，将所有的类封装在一个函数里。别人在调用时，只需要记住这一个函数就行。这个函数也被称为工厂函数，这种模式叫简单工厂模式，也是工厂模式中最简单的一种。</p>
<h2 id="创建简单工厂"><a href="#创建简单工厂" class="headerlink" title="创建简单工厂"></a>创建简单工厂</h2><p>简单工厂模式的理念就是创建对象，</p>
<h3 id="对不同的类进行实例化方式"><a href="#对不同的类进行实例化方式" class="headerlink" title="对不同的类进行实例化方式"></a>对不同的类进行实例化方式</h3><p>假如创建了很多个类，别人在使用时，还需要去找到相对应的类，这样太麻烦了。所以将这些所有的类封装在一个函数里，故只需要记住这一个函数名就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//篮球基类</span></span><br><span class="line"><span class="keyword">let</span> Basketball=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intro=<span class="string">"篮球"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Basketball.prototype=&#123;</span><br><span class="line">    getMember:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"5"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    getBallSize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"big"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//足球基类</span></span><br><span class="line"><span class="keyword">let</span> Football=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intro=<span class="string">"足球"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Football.prototype=&#123;</span><br><span class="line">    getMember:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"11"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    getBallSize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"medium"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//网球基类</span></span><br><span class="line"><span class="keyword">let</span> Tennis=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intro=<span class="string">"网球"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Tennis.prototype=&#123;</span><br><span class="line">    getMember:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    getBallSize:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"small"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运动工厂</span></span><br><span class="line"><span class="keyword">let</span> SportsFactory=<span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"NBA"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Basketball();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"worldCup"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Football();</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"FrenchOpen"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tennis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> football=SportsFactory(<span class="string">"worldCup"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(football);</span><br><span class="line"><span class="built_in">console</span>.log(football.intro);</span><br><span class="line">football.getMember();</span><br></pre></td></tr></table></figure>



<h3 id="创建相似对象"><a href="#创建相似对象" class="headerlink" title="创建相似对象"></a>创建相似对象</h3><p>当很多类有相同的地方时，可以抽象提取出来共用。比如说有一堆书，书名还有出版时间等是不一样的，这就需要针对性的处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">name,time,type</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name=name;</span><br><span class="line">    o.time=time;</span><br><span class="line">    o.type=type;</span><br><span class="line">    o.getName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="keyword">let</span> book1=createBook(<span class="string">"JS"</span>,<span class="string">"2019"</span>,<span class="string">"js"</span>);</span><br><span class="line"><span class="keyword">let</span> book2=createBook(<span class="string">"CSS"</span>,<span class="string">"2019"</span>,<span class="string">"css"</span>);</span><br><span class="line">book1.getName();</span><br><span class="line">book2.getName();</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单工厂有两种方法，一个是实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能。</p>
]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>函数IIFE（关于匿名函数自调用）</title>
    <url>/2020/03/09/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>Immediately-Invoked Function Expression<br>js函数声明和函数表达式的区别</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"yyy"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.x=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"xxx"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure>

<p>上面代码输出y未定义，说明x已经被暴露在全局中。当时以为x是因为使用了window，可是将window去掉之后，x还是暴露在全局。然后继续在前面加上let，发现x总算出错了显示未定义。至于为什么还没有搞懂，枯了~   有空再将函数好好重新学一遍</p>
<p>更新：<br>假如 function fn(){} 是一个赋值语句或表达式的一部分，则认为它是一个函数表达式。而如果 function fn(){} 被包含在一个函数体内，或者位于程序（的最上层）中，则将它作为一个函数声明来解析。显然，在省略标识符的情况下，“表达式” 也就只能是表达式了。</p>
<p>经过查阅发现函数声明和函数表达式在使用上并不是一样的，甚至有点意外</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>)&#125;(); <span class="comment">// 可以</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">2</span>)&#125;();         <span class="comment">//不可以</span></span><br></pre></td></tr></table></figure>

<p>函数表达式可以直接在后面加括号执行，而函数声明不可以。也就是说，函数表达式可以通过直接加()来执行这个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a(); <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> alert(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">b(); <span class="comment">//正常运行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明调用可以提前，但是函数表达式调用必须要先声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">aaa</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">    alert(<span class="keyword">typeof</span> aaa); <span class="comment">// 内部可以找到</span></span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// 1 function</span></span><br><span class="line">aaa(); <span class="comment">// 外部找不到 //  1</span></span><br></pre></td></tr></table></figure>

<p>这里a是函数声明，aaa是函数表达式。可以看出作用域的不同</p>
<p>可是还是没能解决为什么函数表达式在匿名函数中可以被外面访问的问题。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数据类型的几个问题</title>
    <url>/2020/03/09/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>什么是实例？以及其他两个常见问题！</p>
<a id="more"></a>
<h2 id="什么是实例？"><a href="#什么是实例？" class="headerlink" title="什么是实例？"></a>什么是实例？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age,name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p=<span class="keyword">new</span> Person();   <span class="comment">//p是一个实例，Person是一个构造函数。</span></span><br></pre></td></tr></table></figure>

<p>其实可以把实例看成是一个成品，而构造函数是一个模具。</p>
<h2 id="undefined和null的区别？"><a href="#undefined和null的区别？" class="headerlink" title="undefined和null的区别？"></a>undefined和null的区别？</h2><p>undefined:指定义了但是未赋值的对象<br>null:指定义了并赋值为null的对象</p>
<h2 id="什么时候给变量赋值为null？"><a href="#什么时候给变量赋值为null？" class="headerlink" title="什么时候给变量赋值为null？"></a>什么时候给变量赋值为null？</h2><p>一般在最开始定义变量时，这时还不知道输入什么值，但是可以先赋值为null，表明这个变量将要赋值为对象。<br>在变量使用完之后，也可以赋值为null，这样做可以释放内存，被浏览器的垃圾回收器回收。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>对象</title>
    <url>/2020/03/09/%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>对象的深入</p>
<a id="more"></a>
<h2 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h2><p>对象就是用来保存多个数据的容器，变量也可以保存数据，但是只能保存一个数据。</p>
<h2 id="为什么要用对象？"><a href="#为什么要用对象？" class="headerlink" title="为什么要用对象？"></a>为什么要用对象？</h2><p>可以统一管理多个数据</p>
<h2 id="对象由什么组成？"><a href="#对象由什么组成？" class="headerlink" title="对象由什么组成？"></a>对象由什么组成？</h2><p>属性（属性名和属性值）和方法（函数）</p>
<h2 id="什么情况必须使用-去调用对象属性或方法？"><a href="#什么情况必须使用-去调用对象属性或方法？" class="headerlink" title="什么情况必须使用[]去调用对象属性或方法？"></a>什么情况必须使用[]去调用对象属性或方法？</h2><p>1.属性名包含特殊字符时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会报错</span></span><br><span class="line">p[<span class="string">"age-age"</span>]=<span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p[<span class="string">"age-age"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//会报错</span></span><br><span class="line">p.age-age=<span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.age-age);</span><br></pre></td></tr></table></figure>

<p>2.变量名不确定时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="string">"age"</span>;</span><br><span class="line"><span class="keyword">let</span> v=<span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">p.a=v;</span><br><span class="line"><span class="built_in">console</span>.log(p.age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">p[a]=v;</span><br><span class="line"><span class="built_in">console</span>.log(p.age);</span><br></pre></td></tr></table></figure>

<p>上面的错误产生是因为中括号运算符总是能代替点运算符。但点运算符却不一定能全部代替中括号运算符。</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>node学习笔记（一）</title>
    <url>/2020/03/09/node%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><a id="more"></a>

<h2 id="使用node搭建一个web服务器"><a href="#使用node搭建一个web服务器" class="headerlink" title="使用node搭建一个web服务器"></a>使用node搭建一个web服务器</h2><pre><code>几个需要注意的点
    1.在使用response.write后一定要使用response.end
    2.request.url表示页面请求路径
    3.node是运行js代码的一个平台
    4.node.js中没有BOM DOM等，只有ES语法
    5.在node中为其添加了服务器API</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http=<span class="built_in">require</span>(<span class="string">"http"</span>)</span><br><span class="line"><span class="keyword">var</span> server=http.createServer()</span><br><span class="line">server.on(<span class="string">"request"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">request,response</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"request'OK---&gt;"</span>+request.url)</span><br><span class="line">    <span class="keyword">if</span>(request.url==<span class="string">"/"</span>)&#123;</span><br><span class="line">        response.write(<span class="string">"hello node"</span>)</span><br><span class="line">        response.end()</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(request.url==<span class="string">"/login"</span>)&#123;</span><br><span class="line">        response.write(<span class="string">"登录"</span>)</span><br><span class="line">        response.end()</span><br><span class="line">    &#125;<span class="keyword">else</span>(request.url==<span class="string">"/register"</span>)&#123;</span><br><span class="line">        response.write(<span class="string">"注册"</span>)</span><br><span class="line">        response.end()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"server's OK!)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>node学习笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>JS函数编写方式</title>
    <url>/2020/03/09/JS%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h1 id="常规小白写法"><a href="#常规小白写法" class="headerlink" title="常规小白写法"></a>常规小白写法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>但是这样写有一个弊端，虽然自己写写demo可以，但是如果是一个team，那么就会创建出来很多个全局变量，可能和别人创建的变量相同而产生冲突。那么如何规避呢？</p>
<a id="more"></a>
<hr>
<h1 id="使用对象来收编变量"><a href="#使用对象来收编变量" class="headerlink" title="使用对象来收编变量"></a>使用对象来收编变量</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funObject=&#123;</span><br><span class="line">    fun1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fun2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写，在调用时只需要这样写：funObject.fun1();<br>既然是点语法，还可以像下面这样写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funObject=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">funObject.fun1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line">funObject.fun1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>但是这样写，在new一个新的类时，new出来的是不能继承这些方法的，如果想要简单的复制一下，可以这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funObject=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        fun1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        fun2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这样可以简单的复制，但是还不是真正意义上类的创建</p>
<hr>
<h1 id="真正意义上的类"><a href="#真正意义上的类" class="headerlink" title="真正意义上的类"></a>真正意义上的类</h1><p>对上面的代码进行一下改造</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funObject=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fun1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.fun2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在可以把它看成一个类了，所以在在创建对象时需要使用new关键字了。因为使用了new，所以新对象会对类的this上的属性进行复制，故这些新对象都会有属于自己的一套方法，但是，这样做有时候会造成很浪费的消耗！<br>修改一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funObject=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">funObject.prototype=&#123;</span><br><span class="line">    fun1:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    fun2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，在实例化一个新对象后，它所拥有的方法就是funObject原型上的属性了。<br>但是在调用时，假如新对象要连续使用fun1，fun2….  就得重复多次写，故可以在每个属性后加上return this。<br>此时，就可以这样写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test=<span class="keyword">new</span> funObject();</span><br><span class="line">test.fun1().fun2()...</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="函数的prototype"><a href="#函数的prototype" class="headerlink" title="函数的prototype"></a>函数的prototype</h1><p>假如想要给每个函数都添加一个方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.addMethod=<span class="function"><span class="keyword">function</span>(<span class="params">name,fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[name]=fn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> methods=<span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>.addMethod(<span class="string">"fun1"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br><span class="line">methods.fun1();</span><br></pre></td></tr></table></figure>
<p>假如想链式添加方法，则只需要在addMethod中将this返回就行。当然了，也可以链式使用它。<br>完整测试代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">Function</span>.prototype.addMethod=<span class="function"><span class="keyword">function</span>(<span class="params">name,fn</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>[name]=fn;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> x=<span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    x.addMethod(<span class="string">"check"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"check!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;).addMethod(<span class="string">"chicken"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">"chicken"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    x.check().chicken();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javascript设计模式</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/09/hello-world(1)/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hello world</category>
      </categories>
      <tags>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的程序设计--一些扩展(基于ES6)</title>
    <url>/2020/03/09/ES6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<hr>
<h2 id="ES6中新增加的一些方法"><a href="#ES6中新增加的一些方法" class="headerlink" title="ES6中新增加的一些方法"></a>ES6中新增加的一些方法</h2><a id="more"></a>

<h2 id="属性的简洁表示"><a href="#属性的简洁表示" class="headerlink" title="属性的简洁表示"></a>属性的简洁表示</h2><pre><code>对象的方法和属性都可以简洁表示</code></pre><p>直接将变量名写在对象里面，这时变量名就是属性名，变量值就是属性值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="string">"hello"</span></span><br><span class="line"><span class="keyword">var</span> y=&#123;x&#125;</span><br><span class="line"><span class="comment">//var y=&#123;x:"hello"&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x=&#123;</span><br><span class="line">    hello()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">x.hello()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>这是我的第一个基于github的hexo博客</title>
    <url>/2020/03/09/%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Egithub%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<hr>
<h2 id="更新1：-在hexo中-不需要使用三个短横线来显示横线-回车即可-与MD语法略有不同"><a href="#更新1：-在hexo中-不需要使用三个短横线来显示横线-回车即可-与MD语法略有不同" class="headerlink" title="更新1：   在hexo中   不需要使用三个短横线来显示横线   回车即可   与MD语法略有不同"></a>更新1：   在hexo中   不需要使用三个短横线来显示横线   回车即可   与MD语法略有不同</h2><a id="more"></a>

<h2 id="测试代码和分割线"><a href="#测试代码和分割线" class="headerlink" title="测试代码和分割线"></a>测试代码和分割线</h2><h3 id="测试html代码"><a href="#测试html代码" class="headerlink" title="测试html代码"></a>测试html代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mamba666.github.io"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="测试css代码"><a href="#测试css代码" class="headerlink" title="测试css代码"></a>测试css代码</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试js代码"><a href="#测试js代码" class="headerlink" title="测试js代码"></a>测试js代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hexo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试结果发现其实预览并没有什么不同，只是在编辑md时语法会高亮"><a href="#测试结果发现其实预览并没有什么不同，只是在编辑md时语法会高亮" class="headerlink" title="测试结果发现其实预览并没有什么不同，只是在编辑md时语法会高亮"></a>测试结果发现其实预览并没有什么不同，只是在编辑md时语法会高亮</h3><h2 id="上传图片测试"><a href="#上传图片测试" class="headerlink" title="上传图片测试"></a>上传图片测试</h2><ul>
<li><p>使用常规网络地址<br><img src="%22%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Egithub%E7%9A%84hexo%E5%8D%9A%E5%AE%A2/bg1.gif%22" alt="haha"></p>
</li>
<li><p>使用img标签</p>
<img src="http://chuantu.xyz/t6/702/1560911372x3661913030.gif">

</li>
</ul>
<h2 id="列表段落"><a href="#列表段落" class="headerlink" title="列表段落"></a>列表段落</h2><h3 id="可以用-来作为无序列表"><a href="#可以用-来作为无序列表" class="headerlink" title="可以用* + -来作为无序列表"></a>可以用* + -来作为无序列表</h3><ul>
<li>第一项<ul>
<li>嵌套需要加上一个tab </li>
</ul>
</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<h3 id="数字-用来作有序列表"><a href="#数字-用来作有序列表" class="headerlink" title="数字.用来作有序列表"></a>数字.用来作有序列表</h3><p>1.有<br>2.序<br>3.列<br>3.表</p>
<h2 id="段落测试"><a href="#段落测试" class="headerlink" title="段落测试"></a>段落测试</h2><h3 id="段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个回车"><a href="#段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个回车" class="headerlink" title="段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个回车"></a>段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个回车</h3><p>换</p>
<p>行</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><em>222</em>    斜体<br><strong>222</strong>    </p>
<h3 id="删除线：前后各添加两个波浪线"><a href="#删除线：前后各添加两个波浪线" class="headerlink" title="删除线：前后各添加两个波浪线"></a>删除线：前后各添加两个波浪线</h3><p><del>这行文字被删除了</del>      </p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>####u标签和数学公式<br>$\underline{下划线}$<br>$\underline{x+y}$<br><u>下划线</u></p>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h3 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h3><blockquote>
<p>kdb b i em sup sub br</p>
</blockquote>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><blockquote>
<p>在这些前面加上反斜杠来帮助插入普通的符号</p>
<blockquote>
<p>\   反斜线<br>`   反引号<br>*   星号<br>_   下划线<br>{}  花括号<br>[]  方括号<br>()  小括号<br>#   井字号<br>+   加号<br>-   减号<br>.   英文句点<br>!   感叹号</p>
</blockquote>
</blockquote>
<p>##以上就是个人这两天的MD总结，日后有新的体会还会继续更新——2019.6.19 11:26</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo使用方法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2020/03/09/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>数据类型远不止基础学到的那些东西</p>
<a id="more"></a>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>整体上分为两大类：基本（值）类型；对象（引用）类型。</p>
<h3 id="基本（值）类型"><a href="#基本（值）类型" class="headerlink" title="基本（值）类型"></a>基本（值）类型</h3><blockquote>
<ul>
<li>String</li>
<li>Boolean</li>
<li>Number</li>
<li>Null</li>
<li>Undefined</li>
</ul>
</blockquote>
<h3 id="对象（引用）类型"><a href="#对象（引用）类型" class="headerlink" title="对象（引用）类型"></a>对象（引用）类型</h3><pre><code>&gt; Object   以下都是Object
&gt; Function  可以执行的对象
&gt; Array     有下标的对象，并且数据都是有顺序的</code></pre><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><blockquote>
<ul>
<li>typeof   返回数据类型的字符串表达式</li>
<li>instanceof    专门判断对象的具体类型（函数还是数组）  </li>
<li>===    全等，不会做类型的转换，不要使用==。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a,<span class="keyword">typeof</span> a)   <span class="comment">//==&gt;undefined,"undefined"</span></span><br><span class="line"><span class="keyword">let</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(tyopof a===<span class="string">"number"</span>)   <span class="comment">//==&gt;true  在判断数据类型时，不要用大写！</span></span><br></pre></td></tr></table></figure>

<p>A instanceof B   :  指A是否为B的一个实例化对象，正确返回true，错误返回false。</p>
<p>这里要特别注意，在使用对象的属性时，一定不要直接写属性，一定一定要在属性前带上对象名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a=&#123;</span><br><span class="line">    b:[<span class="string">"h"</span>,<span class="string">"e"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">"l"</span>],</span><br><span class="line">    c:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"hello"</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.b <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.c <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.b <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.c <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> a.b);     <span class="comment">//==&gt; 这里a.b是Array，但是使用typeof显示是object，下面的function正常显示。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a.c);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue组件的深入理解</title>
    <url>/2020/03/09/vue%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<h2 id="若干vue组件笔记以及心得"><a href="#若干vue组件笔记以及心得" class="headerlink" title="若干vue组件笔记以及心得"></a>若干vue组件笔记以及心得</h2><a id="more"></a>

<h2 id="定义全局组件时在html中显示出现BUG，使用is属性解决"><a href="#定义全局组件时在html中显示出现BUG，使用is属性解决" class="headerlink" title="定义全局组件时在html中显示出现BUG，使用is属性解决"></a>定义全局组件时在html中显示出现BUG，使用is属性解决</h2><p>要注意在html中有的标签是必须连着用的，比如tbody和tr，ul和li，select和option,在这里tbody里面是一个自定义全局组件而不是tr，所以会产生BUG。</p>
<p>BUG代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">row</span>&gt;</span><span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">row</span>&gt;</span><span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">row</span>&gt;</span><span class="tag">&lt;/<span class="name">row</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"row"</span>,&#123;</span><br><span class="line">        template:<span class="string">"&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>改进后的HTML代码：  使用vue的is属性，将tr=row组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="子组件中的data定义必须是一个函数而不能是一个对象"><a href="#子组件中的data定义必须是一个函数而不能是一个对象" class="headerlink" title="子组件中的data定义必须是一个函数而不能是一个对象"></a>子组件中的data定义必须是一个函数而不能是一个对象</h2><p>不然会报错，根组件是new Vue({}),子组件为自定义的全局组件</p>
<p>这里的想法是将子组件data的值传入模板template的插值语法中然后显示出来，这个思路是对的，但是呢不能在子组件的data中写入数据，必须是函数！！！</p>
<p>这样设计的原因是因为子组件不像根组件只会被调用一次，而是可能会反复多次调用，在多次调用时不希望和其他子组件产生冲突，而是每一个子组件在调用时都有自己的独立的数据，所以通过一个函数来返回一个对象的目的就是每个子组件都有自己的数据存储。</p>
<p>error code:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"row"</span>,&#123;</span><br><span class="line">        data:&#123;</span><br><span class="line">            content:<span class="string">"this's a row"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        template:<span class="string">"&lt;tr&gt;&lt;td&gt;&#123;&#123;content&#125;&#125;&lt;/td&gt;&lt;/tr&gt;"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>改进后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"row"</span>,&#123;</span><br><span class="line">        data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                content:<span class="string">"this's content"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template:<span class="string">"&lt;tr&gt;&lt;td&gt;&#123;&#123;content&#125;&#125;&lt;/td&gt;&lt;/tr&gt;"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="操作DOM—–ref的使用—–与组件的关联"><a href="#操作DOM—–ref的使用—–与组件的关联" class="headerlink" title="操作DOM—–ref的使用—–与组件的关联"></a>操作DOM—–ref的使用—–与组件的关联</h2><p>虽然VUE不推荐直接操作DOM，但是在动画等必要的情况下还是得操作DOM</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">ref</span>=<span class="string">"hello"</span> </span></span><br><span class="line"><span class="tag">        @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span>,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="comment">// $refs指vue中的所有引用</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.$refs.hello)   <span class="comment">//  ==&gt;&lt;div&gt;hello world&lt;/div&gt;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>虽然以上html代码中ref在一个标签中可以获取一个DOM元素，但是如果放在一个组建中就可以直接获得其组件</p>
<p>现在来做一个加法的demo，即三个div，第三个div可以动态求出前两个div数字之和</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span> <span class="attr">ref</span>=<span class="string">"counter1"</span> @<span class="attr">change</span>=<span class="string">"handleChange"</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span> <span class="attr">ref</span>=<span class="string">"counter2"</span> @<span class="attr">change</span>=<span class="string">"handleChange"</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;total&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"counter"</span>,&#123;</span><br><span class="line">        template:<span class="string">"&lt;div @click='handleClick'&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;"</span>,</span><br><span class="line">        data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                num:<span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.num++</span><br><span class="line">                <span class="keyword">this</span>.$emit(<span class="string">"change"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            total:<span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleChange:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.total=<span class="keyword">this</span>.$refs.counter1.num+<span class="keyword">this</span>.$refs.counter2.num</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="父子组件传递参数的demo"><a href="#父子组件传递参数的demo" class="headerlink" title="父子组件传递参数的demo"></a>父子组件传递参数的demo</h2><p>code:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过属性的形式向子组件传递数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">"3"</span> @<span class="attr">change</span>=<span class="string">"handleIncrease"</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">counter</span> <span class="attr">:count</span>=<span class="string">"2"</span> @<span class="attr">change</span>=<span class="string">"handleIncrease"</span>&gt;</span><span class="tag">&lt;/<span class="name">counter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;total&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//自定义局部组件</span></span><br><span class="line">    <span class="keyword">var</span> counter=&#123;</span><br><span class="line">        props:[<span class="string">"count"</span>],</span><br><span class="line">        template:<span class="string">"&lt;div @click='handleClick'&gt;&#123;&#123;num&#125;&#125;&lt;/div&gt;"</span>,</span><br><span class="line">        data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                num:<span class="keyword">this</span>.count</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.num+=<span class="number">2</span></span><br><span class="line">                <span class="keyword">this</span>.$emit(<span class="string">"change"</span>,<span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            total:<span class="number">5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//注册局部组件</span></span><br><span class="line">        components:&#123;</span><br><span class="line">            counter:counter</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleIncrease:<span class="function"><span class="keyword">function</span>(<span class="params">step</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.total+=step</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="组件的参数校验"><a href="#组件的参数校验" class="headerlink" title="组件的参数校验"></a>组件的参数校验</h2><p>子组件有权对内容做约束叫做参数的校验，一般情况下传入的参数代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">content</span>=<span class="string">"hello world"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"child"</span>,&#123;</span><br><span class="line">        props:[<span class="string">"content"</span>]</span><br><span class="line">        template:<span class="string">"&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;"</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>在组件中props作为一个数组接收这个参数content，如果要对content做校验则改写成一个对象，包括type,required,default,validator,代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"child"</span>,&#123;</span><br><span class="line">        props:&#123;</span><br><span class="line">            <span class="comment">//校验为字符串</span></span><br><span class="line">             content:<span class="built_in">String</span></span><br><span class="line">            <span class="comment">//校验为数字</span></span><br><span class="line">             content:<span class="built_in">Number</span></span><br><span class="line">            <span class="comment">//校验为字符串或者数字用一个数组表示</span></span><br><span class="line">            content:[<span class="built_in">String</span>,<span class="built_in">Number</span>]</span><br><span class="line">            <span class="comment">//甚至还能跟一个对象</span></span><br><span class="line">            content:&#123;</span><br><span class="line">                type:<span class="built_in">String</span>,</span><br><span class="line">                <span class="comment">//required：true表示，子组件接收的这个content属性时必须传入的</span></span><br><span class="line">                required:<span class="literal">true</span>,</span><br><span class="line">                <span class="comment">//default:"xxx"表示，当content没有内容是，显示default的值</span></span><br><span class="line">                <span class="keyword">default</span>:<span class="string">"default value"</span>,</span><br><span class="line">                <span class="comment">//甚至能作出更加复杂的校验,validator是个boolean，返回true则正确显示，返回false则错误</span></span><br><span class="line">                validator:<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> (val.length&gt;=<span class="number">5</span>)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        template:<span class="string">"&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;"</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="非props特性"><a href="#非props特性" class="headerlink" title="非props特性"></a>非props特性</h2><p>props特性的特点，父组件调用子组件时，在DOM元素上是不会显示这个调用的</p>
<p>非props特性的特点刚好和props特性相反，即子组件中没有定义props去接收这个属性，在template中使用这个属性就会报错。假如template没有使用这个属性，则在DOM中会留下这个属性，所以这里与props特性也刚好相反</p>
<h2 id="给组件绑定原生事件"><a href="#给组件绑定原生事件" class="headerlink" title="给组件绑定原生事件"></a>给组件绑定原生事件</h2><p>在子组件中绑定了一个自定义事件后，并不会生效，因为绑定在组件上的事件会被替换成template中的html，所以会失效<br>code:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"child"</span>,&#123;</span><br><span class="line">        template:<span class="string">"&lt;div&gt;child&lt;/div&gt;"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span>,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">"click"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以对JS将methods和绑定事件位置修改一下<br>code:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"child"</span>,&#123;</span><br><span class="line">        template:<span class="string">"&lt;div @click='handleClick'&gt;child&lt;/div&gt;"</span>,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">"click"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span>,</span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>前一种绑定是自定义事件，后一种是绑定的原生事件，如果想让自定义事件生效，修改如下<br>code：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"child"</span>,&#123;</span><br><span class="line">        template:<span class="string">"&lt;div @click='handleClick'&gt;child&lt;/div&gt;"</span>,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">"click"</span>)   <span class="comment">//=====&gt;先触发</span></span><br><span class="line">                <span class="keyword">this</span>.$emit(<span class="string">"click"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span>,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                alert(<span class="string">"clickxxx"</span>)    <span class="comment">//====&gt;后触发</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，还有一种办法我就是在组件自定义上面加上.native修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> @<span class="attr">click.native</span>=<span class="string">"handleClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="非父子组件间的传值（BUS）"><a href="#非父子组件间的传值（BUS）" class="headerlink" title="非父子组件间的传值（BUS）"></a>非父子组件间的传值（BUS）</h2><h2 id="在vue中使用插槽"><a href="#在vue中使用插槽" class="headerlink" title="在vue中使用插槽"></a>在vue中使用插槽</h2><p>先看一段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">content</span>=<span class="string">"&lt;p&gt;world&lt;/p&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">"child"</span>,&#123;</span><br><span class="line">    props:[<span class="string">"content"</span>],</span><br><span class="line">    template:<span class="string">"&lt;div&gt;&lt;p&gt;hello&lt;/p&gt;&lt;div v-html='this.content'&gt;&lt;/div&gt;&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可发现当子组件中传入父组件的值时，假如子组件中传的值过多过繁，则不太好。并且要注意，子组件模板中不能直接写传入的值，必须用v-html指令。不然会把传入的值不转化html直接显示。</p>
<p>name如何通过插槽优雅的向子组件传递DOM结构呢？</p>
<p>在html中直接在子组件内插入要传递的DOM结构，在JS中子组件模板内用slot语法</p>
<p>slot新特性：<br>    在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)。它取代了 slot 和 slot-scope 这两个目前已被废弃但未被移除且仍在文档中的特性。</p>
<pre><code>具名插槽的意思是值给slot起了名字，这样就可以在子组件模板中调用特定的插槽，当然具名插槽也有默认值</code></pre><p>代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body-content</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;div class="header" slot="header"&gt;header&lt;/div&gt; --&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">"body-content"</span>,&#123;</span><br><span class="line">    template:<span class="string">"&lt;div&gt;&lt;slot name='header'&gt;&lt;h1&gt;xxx&lt;/h1&gt;&lt;/slot&gt;&lt;div class='content'&gt;content&lt;/div&gt;&lt;slot name='footer'&gt;&lt;/slot&gt;&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>子组件内数据可以被父页面拿到(解决了数据只能从父页面传递给子组件)</p>
<p>必须是template开头和结尾的插槽</p>
<p>v-slot确定子组件需要接收的数据放在哪</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件要显示一个功能==&gt;列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;props.item&#125;&#125;-hello<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">"child"</span>,&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            list:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:<span class="string">"&lt;div&gt;&lt;ul&gt;&lt;slot v-for='item of list' v-bind:item='item'&gt;&lt;/slot&gt;&lt;/ul&gt;&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#root"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="动态组件和v-once"><a href="#动态组件和v-once" class="headerlink" title="动态组件和v-once"></a>动态组件和v-once</h2><p>需求：点击按钮实现切换显示内容</p>
<p>常规代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-one</span> <span class="attr">v-if</span>=<span class="string">"type==='child-one'"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-one</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child-two</span> <span class="attr">v-if</span>=<span class="string">"type==='child-two'"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-two</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleBtnClick"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">"child-one"</span>,&#123;</span><br><span class="line">    template:<span class="string">"&lt;div&gt;child-one&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">"child-two"</span>,&#123;</span><br><span class="line">    template:<span class="string">"&lt;div&gt;child-two&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#root"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        type:<span class="string">"child-one"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        handleBtnClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type=(<span class="keyword">this</span>.type===<span class="string">"child-one"</span>?<span class="string">"child-two"</span>:<span class="string">"child-one"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用动态组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"type"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;child-one v-if="type==='child-one'"&gt;&lt;/child-one&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;child-two v-if="type==='child-two'"&gt;&lt;/child-two&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleBtnClick"</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">"child-one"</span>,&#123;</span><br><span class="line">    template:<span class="string">"&lt;div&gt;child-one&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">"child-two"</span>,&#123;</span><br><span class="line">    template:<span class="string">"&lt;div&gt;child-two&lt;/div&gt;"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el:<span class="string">"#root"</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        type:<span class="string">"child-one"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        handleBtnClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type=(<span class="keyword">this</span>.type===<span class="string">"child-one"</span>?<span class="string">"child-two"</span>:<span class="string">"child-one"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>v-once </p>
<p>只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>vue动画特效</title>
    <url>/2020/03/09/Vue%E4%B8%AD%E7%9A%84%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<hr>
<h2 id="若干vue动画特效笔记以及心得"><a href="#若干vue动画特效笔记以及心得" class="headerlink" title="若干vue动画特效笔记以及心得"></a>若干vue动画特效笔记以及心得</h2><a id="more"></a>

<h2 id="vue中css动画原理"><a href="#vue中css动画原理" class="headerlink" title="vue中css动画原理"></a>vue中css动画原理</h2><p>在需要动画特效的DOM外面必须有一层transition标签用于元素作为单个元素/组件的过渡效果。transition只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在检测过的组件层级中。</p>
<pre><code>当一个元素被transition包裹之后，vue会自动分析元素CSS样式，然后构建一个动画的流程，这个时候会在DOM元素上加上两个class:&quot;fade-enter&quot;,&quot;fade-enter-active&quot;。当动画执行到第一帧执行结束后，transition分析这个是一个动画效果后，在动画的第二帧时，会把“fade-enter”去掉，加上“fade-enter-to”。动画继续执行到结束的一瞬间，会把还存在的两个class去除。</code></pre><p>这是在官方文档中的描述：</p>
<p>在进入/离开的过渡中，会有 6 个 class 切换。<br>1.v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。<br>2.v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。<br>3.v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。<br>4.v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。<br>5.v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。<br>6.v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</p>
<pre><code>对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enter。</code></pre><p>一个简单的demo：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.fade-enter</span>&#123;</span><br><span class="line">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.fade-enter-active</span>&#123;</span><br><span class="line">        <span class="attribute">transition</span>:opacity <span class="number">3s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.fade-leave-to</span>&#123;</span><br><span class="line">        <span class="attribute">opacity</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.fade-leave-active</span>&#123;</span><br><span class="line">        <span class="attribute">transition</span>:opacity <span class="number">3s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        hello world</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#root"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            show:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleClick:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.show=!<span class="keyword">this</span>.show</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="在vue中使用Animate-css库"><a href="#在vue中使用Animate-css库" class="headerlink" title="在vue中使用Animate.css库"></a>在vue中使用Animate.css库</h2>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>hello vue</title>
    <url>/2020/03/09/vue%E5%88%9D%E8%AF%95%E7%89%9B%E5%88%80-hello%20vue/</url>
    <content><![CDATA[<hr>
<p>代码示意</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &#123;&#123;&#125;&#125;：插值表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- v-model：指令 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">//key:value</span></span><br><span class="line">    <span class="comment">//key的取值为vue框架定义的具有特定意义的相关属性</span></span><br><span class="line">    <span class="comment">//在API中所有以选项开头的都是可以作为key值的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//el:element select DOM选择器</span></span><br><span class="line">    el:<span class="string">"#app"</span>,<span class="comment">//vue实例和页面容器的关联,同时取值要遵循css的语法，并且只针对第一个匹配的元素生效！  el实现方法时docuemnt.querySelector(el);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例的数据仓库</span></span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:<span class="string">"msg111"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>v-cloak指令</title>
    <url>/2020/03/09/v-cloak%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<hr>
<p>在打开网页过程中，会遇到网络不好的问题，即html显示出来了但是js还在加载，如果使用了vue框架，则有可能在页面上显示若干个双大括号这样的插值表达式，并且会暴露给用用户所使用的vue语法。<br>所以如何避免呢？</p>
<hr>
<a id="more"></a>

<h2 id="v-cloak官方解释"><a href="#v-cloak官方解释" class="headerlink" title="v-cloak官方解释"></a>v-cloak官方解释</h2><ul>
<li><p>不需要表达式</p>
</li>
<li><p>用法：这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>
</li>
<li><p>代码示例</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[v-cloak]</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div v-cloak&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自我理解"><a href="#自我理解" class="headerlink" title="自我理解"></a>自我理解</h3><p>在用法上必须和css代码配合使用，自己模拟了一个网络延迟的场景</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-cloak</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[v-vloak]</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#app"</span>,</span><br><span class="line">        data:&#123;</span><br><span class="line">            msg:<span class="string">"v-cloak"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>

<p>第一个p标签不会显示出插值表达式语法，而是在页面发生延迟加载完成之后才显示，第二个在页面延迟时也会显示插值表达式。</p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>可能会有疑问，为什么使用了v-cloak之后css隐藏了html，但是js生效之后又显示了呢？</p>
<p>这个问题是因为vue实例生效后会移除vue指令，即html上不再有v-cloak，所以css也无法在匹配到html中的指定标签。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>SPA&amp;MVVM两种设计模式思想简单分析</title>
    <url>/2020/03/09/SPA&amp;MVVM/</url>
    <content><![CDATA[<hr>
<h1 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h1><h2 id="名称由来"><a href="#名称由来" class="headerlink" title="名称由来"></a>名称由来</h2><p>single pages application 单页应用程序</p>
<a id="more"></a>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>spa即将页面所有活动局限在一个页面上，称为主页。在一般的页面上想要改变现实内容都是重新请求一个document，但是spa设计的页面上是通过JS操作DOM来改变页面内容的，即spa不会去重新请求一个document。</p>
<h2 id="应用上"><a href="#应用上" class="headerlink" title="应用上"></a>应用上</h2><p>微信小程序，vue等都是SPA。</p>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><h2 id="名称由来-1"><a href="#名称由来-1" class="headerlink" title="名称由来"></a>名称由来</h2><p>model-view-viewmodel 模型-视图-视图模型</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>让开发者只需要关心model和view这两块，而不用去花大量时间关心页面和数据的关系<br>vue是实现了mvvm设计思想的框架！</p>
<h2 id="代码示意"><a href="#代码示意" class="headerlink" title="代码示意"></a>代码示意</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">		<span class="comment">// model 页面内容的相关数据</span></span></span><br><span class="line"><span class="actionscript">		<span class="keyword">var</span> msg=<span class="string">"msg11"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">		<span class="comment">// view-model MVVM设计的核心思想，是连接view和model的桥梁</span></span></span><br><span class="line"><span class="javascript">		<span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> h1DOM=<span class="built_in">document</span>.getElementById(<span class="string">"h1DOM"</span>);</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> inputDOM=<span class="built_in">document</span>.getElementById(<span class="string">"inputDOM"</span>);</span></span><br><span class="line">			h1DOM.innerHTML=msg;</span><br><span class="line">			inputDOM.value=msg;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">			inputDOM.addEventListener(<span class="string">"input"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">				msg=<span class="keyword">this</span>.value;</span></span><br><span class="line">				h1DOM.innerHTML=msg;</span><br><span class="line">				inputDOM.value=msg;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 视图模型 view --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"h1DOM"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"inputDOM"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>你懂我意思吗</title>
    <url>/2019/06/19/%E4%BD%A0%E6%87%82%E6%88%91%E6%84%8F%E6%80%9D%E5%90%97/</url>
    <content><![CDATA[<p><strong>只因人在风中，聚散不由你我。</strong></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
